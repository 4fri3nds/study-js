<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.1/css/all.css" integrity="sha384-O8whS3fhG2OnA5Kas0Y9l3cfpmYjapjI0E4theH4iuMD+pLhbf6JI0jIMfYcK3yZ"
    crossorigin="anonymous">
  <link rel="stylesheet" href="../../css/style.css">
</head>

<body>
  <div class="nav">
    <div id="bread-crumps"></div>
    <div class="search">
      <span>&#64;</span>
      <input type="text">
      <button>search</button>
    </div>
  </div>
  <div class="header">
    <div id="menu"></div>
  </div>
  <div class="content">

    <div class="info">
      <div class="info-left">
        <h4 class="links-themes-title">Functions</h4>
        <!-- TABS NAV-->
        <ul class="tabs-nav-list">
          <li class="tabs-nav-item active" onclick="openMark(event,'mark1')">Примеры кода</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark2')">__This__</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark3')">Return</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark4')">Примеры</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark5')">Arguments</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark6')">Get/Set/Decriptor</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark7')">Рекурсия</li>
        </ul>
        <!-- END NAV -->
      </div>
      <div class="info-right">
        <div id="extra-menu" class="links-themes-list"></div>
        <ul class="tabs-content-list info-right-content">
          <li id="mark1" class="tabs-content-item active">
            <!-- 1 -->
            <div class="sub-title">Main</div>
            <div class="title">Примеры использования</div>
            <fieldset>
              <legend>1. Функции на самом деле</legend>
              <p>
                Функции в Javascript'е — немного странные штуки. Функции в Javascript'е — на самом деле объекты. А именно, объекты класса
                Function, создаваемые конструктором Function. В объекте Function содержится строка с JS-кодом данной функции.
              </p>

              <h3>
                Нужно не забывать что повторяющаяся функция переписывает переменные на начальные, если они находятся в середине.
              </h3>
            </fieldset>
            <fieldset>
              <legend>2. Функции не копируются</legend>
              <h3>В js функции не копируются, а ссылаются друг на друга.</h3>
              <pre>
                <code>
                  function func() { alert('!'); }); 
                  var test = func; //И test и func указывают на одну и ту же функцию
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>3. Разновидности функций</legend>
              <h3>Есть два вида обьявления</h3>
              <pre>
                <code>
                  <b>Function - Declaration:</b> ее вызов будет работать в любом месте
                  function func() { //... }); |
                  <b>Function - Expression:</b> ее вызов будет работать только с кодом сверху-вниз
                  func = function() { //... });
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>4. Функция суть - код который повторяется</legend>
              <b>Ошибка:</b> Первый пример вызовит функцию без клика
              <pre>
                <code>
                  but.onclick = func(x, y); //вызов без клика
                  but.onclick = func() { func(x, y) }; //вызов по клику
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>5. Метод Arguments</legend>
              <h3>обращаясь к методу arguments[i] мы можем передать любое кол-во параметров</h3>
              <pre class="code">
                <code>
                  function display() {
                    var z = 1;
                    for(var i=0; i < arguments.length; i++) {
                      z *= arguments[i];
                      console.log(z);
                    }
                  };
                  
                  display(6); // 6
                  display(6, 4) // 24
                  display(6, 4, 5) // 120
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>6. Проброс функции в глобальную область</legend>
              <h3>Вызов из анонимной замыкающей функции</h3>
              <pre class="code">
                <code>
                  (function(){ 
                    var title = "Hello World"; 
                    function showTitle(){ 
                      alert(title); 
                    } 
                    window.showSimpleTitle = showTitle; 
                  })();
                  
                  showSimpleTitle();
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>7. Функция как часть обьекта - метод</legend>
              <h3>Вызов функций из обьекта</h3>
              <pre class="code">
                <code>
                  var exampleObject = { 
                    "title": "Example Title", 
                    "showTitle": function(){ 
                      alert(this.title); 
                    } 
                  };
                  
                  exampleObject.showTitle();
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>8. Общая функция на два обьекта</legend>
              <h3>Вызов функции в контексте обьекта</h3>
              <pre class="code">
                <code>
                  function showTitle() { 
                    alert(this.title); 
                  } 
                  
                  var objectA = { 
                    "title": "Title A", 
                    "showTitle": showTitle 
                  }; 
                  
                  var objectB = { 
                    "title": "Title B", 
                    "showTitle": showTitle 
                  };
                  
                  objectA.showTitle(); 
                  objectB.showTitle();
                </code>
              </pre>
              <i> !!! Частая ошибка чтобы this в функции showTitle ссылалась на обьект exampleObject - нужно эту функцию запускать
                в контексте обьекта</i>
              <pre>
                  <code>
                    exampleObject.showTitle - плохо
                    exampleObject.showTitle() - хорошо
                  </code>
                </pre>
            </fieldset>
            <fieldset>
              <legend>9. Функция как параметр</legend>
              <h3>Можно передать функцию параметром</h3>
              <pre class="code"> 
                <code>
                  var get1 = function() { return 1; } 
                  var get2 = function() { return 2; }
                  
                  function go(func1, func2) { 
                    alert(func1() + func2()); 
                  } 
                  
                  go(get1, get2); //выведет 3
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>10. При вызове функции в ее аргумент записываем функцию - и получаем слияние функций</legend>
              <h3>Так можно использовать анонимную функцию</h3>
              <pre>
                <code>
                  function go(func) { 
                    func(); // а здесь мы говорим что аргумент этой функции - функция которая будет вызвана при ее передаче в качестве аргумента
                  }); 
                  
                  go(function() { alert('!') }); // при вызове передаем саму функцию аргументом
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>11. Вызов функции с другой функции</legend>
              <h3>функция возвращает внутреннюю функцию. Вызвать внутреннюю можно
                <b>func()()</b>
              </h3>
              <pre class="code">
                <code>
                  function func() { 
                    return function() { 
                      return 'yam!'; 
                    }; 
                  } 
                  
                  alert( func()() ); // 'yam!'
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>12. Просто космос</legend>
              <h3>Жанглирование вызовами функции. или Функция-в-функции
                <div class="sub-title">Догадайся что будет на выходе</div>
              </h3>
              <pre class="code">
                <code>
                  function getTitle (){ 
                    var title = "default title"; 
                    var showTitle = function(){ 
                      alert(title); 
                    }; 
                    var setTitle = function(newTitle){
                      title = newTitle; 
                    }; return { 
                      "showTitle": showTitle, 
                      "setTitle": setTitle 
                    }; 
                  } 
                  var t = getTitle(); 
                  t.showTitle(); 
                  t.setTitle("Hello World"); 
                  t.showTitle();
                  
                  var t1 = getTitle(); 
                  t1.setTitle("Hello World 1"); 
                  var t2 = getTitle(); 
                  t2.setTitle("Hello World 2"); 
                  t1.showTitle(); 
                  t2.showTitle();
                </pre>
              </code>
            </fieldset>
            <fieldset>
              <legend>13. Обнуление счетчика</legend>
              <h3>
                Если что то превывает нужное кол-во. Мы можем его обнулить. Вот таким вот незамысловатым образом.
              </h3>
              <pre class="code">
                <code>
                  if (x >= colorArr.length) { 
                    x = 0 
                  }
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>14. Космос-2 или фигурки</legend>
              <p>ФУНКЦИЯ В функции и область видимости</p>
              <p>
                вызов функции в другой функции
              </p>

              <pre class="code">
                <code>    
                  var landscape = function () { 
                    var result = ""; 
                    var flat = function (size) { 
                      for (var count = 0; count < size; count++) {
                        result +="_" ; 
                      } 
                    }; 
                    
                    var mountain = function (size) { 
                      result +="/" ; for (var count=0 ; count < size; count++) { 
                        result +="'"; 
                      } 
                      result +='\\' ; 
                    }; 
                    
                    flat(3); 
                    mountain(4); 
                    flat(6); 
                    mountain(1); 
                    flat(1); 
                    return result; 
                  };
                  
                  div(landscape());
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>15. Функция js - это обьект</legend>
              <blockquote>
                Функция в JavaScript является объектом, поэтому можно присваивать свойства прямо к ней.
              </blockquote>
              <ul>
                <li>Создать переменную в функции, будет видно только в ф-ции. Это использование функции <b>«как функции»</b>.</li>
                <li>А свойство у функции – доступно отовсюду и всегда. Это – использование функции <b>«как объекта».</b></li>
              </ul>
              <pre class="code">
                <code>    
                <b>// 1. Задать свойство снаружи</b>
                 function f() {} 
                 
                 f.test = 5;
                 alert( f.test );

                <b>// 2. Задать свойство изнутри</b>
                function makeCounter() { 
                  function counter() { 
                    return counter.currentCount++; 
                  }; 
                  counter.currentCount = 1; 
                  return counter;
                } 
                var counter = makeCounter(); 
                alert( counter() ); // 1 
                alert( counter() ); // 2

                </code>
              </pre>
              <blockquote>
                При запуске пример работает также как из замыкания. 
                <br>Принципиальная разница – во внутренней механике и в том, что свойство функции, в отличие от переменной из замыкания – общедоступно, к нему имеет доступ любой, у кого есть объект функции. Например, можно взять и поменять счётчик из внешнего кода вот так:
              </blockquote>
              <pre class="code">
                <code>
                  var counter = makeCounter(); 
                  alert( counter() ); // 1 
                  counter.currentCount = 5; 
                  alert( counter() ); // 5
                </code>
              </pre>
            </fieldset>
            <!-- end 1 -->
          </li>
          <li id="mark2" class="tabs-content-item">
            <!-- 2 -->
            <div class="sub-title">Main</div>
            <div class="title">__This__</div>
            <fieldset>
              <legend>1. This</legend>
              <h3>
                Передача и использование this в функции
                func.apply(context, args) // this = context (явная передача)

                func.apply( context, [args] )
                func.call( context, arg1, arg2 )
                func.bind( context, arg1, arg2 )

                <b>Пример</b>
                var user = {
                  name: 'Андрей',
                  sayHi: function() {
                    alert('Привет. Меня зовут ' + this.name);
                  }
                }
                
                var user2 = {
                  name: 'Вася',
                }
                
                user.sayHi.apply(user2);
              </h3>
              <p>
                Также верхнее this можно положить опять таки в переменную, которую передать в функции пониже.
              </p>
              <pre><code>let that = this.value;</code></pre>
            </fieldset>
            <fieldset>
              <legend>1.5 This в addEventListener && OOP</legend>
              <blockquote>
                function(){}.bind(this) -- это закрепит за этой функцией this

                this.elem.addEvent( 'click', somefunc.call(this) ) -- это переопределит с this с элемента на тот в котором этот элемент вызвался this.elem  
              </blockquote>
              <pre class="code">
                <code>
                  
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>2. Методы this</legend>
              <pre>
                <code>
                  func.call(elem, x1, x2)
                  func.apply(elem, [x1, x2]) 
                  func.bind(elem)
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>2. методы this</legend>
              <p>
                func.call(elem, x1, x2) func.apply(elem, [x1, x2]) func.bind(elem)
              </p>
              <pre>
                <code>
                  <b>result: Значение этого элемента : 66</b>        
                  let elem = document.getElementsByTagName('input')[0]; 
                  
                  function func(x1, x2) { 
                    console.log("Значение" + x1 + x2 + this.value);
                  } 
                  
                  func.call(elem, ' этого', ' элемента : ');        I method
                  func.apply(elem, [' этого', ' элемента : ']);     II method
                  
                  let arr = [' этого', ' элемента : ']; 
                  func.apply(elem, arr);                            III method
                  
                  let newFunc = func.bind(elem);                   IV method
                  newFunc("один", "два"); //это аналог func(), если мы что-то меняем изначальной функции меняется и в newFunc(). Мы точно такжне можем передать в нее параметры
                  
                  //Если нету addEventListener такое не будет работать
                  function func1(v) { 
                    console.log(v); 
                  } 
                  div(func1(this));
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>3. this аргументом</legend>
              <h3>Также можно передать this с одной функции другой параметром</h3>
              <p>
                мы как-бы вызываем в другой фукции и передаем ей то что содержится в этой но не хватает в той, которой мы передаем.
              </p>
              <pre class="code">
                <code>
                  function value(val) { 
                    return val.value; 
                  } 
                  elem.onblur = function someFunc() { 
                    value(this); //здесь мы передаем this в функцию
                    value() }
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>4. Дать и забрать аттр по клику</legend>
              <p>
                Только при вызове функции мы указывает this(где мы указываем элементы с которымм что-то должна зделать функция). В сасой
                функции универсальной фун-ции this будет window или undefined.
              </p>
              <pre class="code">
                <code>
                  function addEvent(remove, add, elem) { 
                    elem.removeEventListener('click', remove); 
                    elem.addEventListener('click', add); 
                  };
                  addEvent(this, first, lost);
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>5. Своя армия функций</legend>
              <p>
                Если функция в цикле то она присваивает i только последнее значение. Ибо она запускается, когда цикл уже закончен. Следовательно shooter(i) везде будет одинаковым. Но если запись будет такая то каждой функции призначится свое значение итерации - i. 
              </p>
              <pre class="code">
                <code>
                  function makeArmy() { 
                    var shooters = []; 
                    for (var i = 0; i < 10; i++)(function (i) { 
                      var shooter=function () { 
                        alert(i);
                      }; 
                      shooters.push(shooter); 
                    })(i); 
                    return shooters; 
                  } 
                  var army = makeArmy(); 
                  army[0](); // 0 
                  army[1](); // 1
                </code>
              </pre>
            </fieldset>
            <!-- end 2 -->
          </li>
          <li id="mark3" class="tabs-content-item">
            <!-- 3 -->
            <div class="sub-title">Main</div>
            <div class="title">Конструкторы</div>
            <fieldset>
              <legend>1. Синтаксис</legend>
              <blockquote>
                Функции-конструкторы это те, которые мы определяем через new экземпляр.
                Конструктор потому-что на выходе мы получаем обьект, сколько угодно обьектов.
                Любая функция может быть вызвана как конструктор.
              </blockquote>
              <pre class="code">
                <code>
                  <b>Конструкторы принаято называем с большой Буквы</b>
                  function Animal(name) { 
                    this.kind = name; 
                    this.walk = false; 
                    this.fly = false; 
                    this.sweem = false; 
                  } 
                  
                  let monk = new Animal('Monkey');
                  monk.walk = true;

                  let eagle = new Animal(); //name = undef 
                  eagle.kind = ('Eagle'); 
                  eagle.fly = true; 
                  
                  console.log(typeof eagle); // object 
                  console.log(eagle); 
                  // Animal {kind: "Eagle", walk: false, fly: true, sweem: false}

                  <b>Можно без скобок</b>
                  var animal = new BigAnimal; // <-- без скобок 
                  var animal = new BigAnimal(); // то же самое
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>2. Методы Конструктора</legend>
              <blockquote>
                ..
              </blockquote>
              <pre class="code">
                <code>
                  <b>В Конструкторе удобно хранить локальные переменные и функции</b>
                  function People() { 
                    let year = 2018; // вспомогательная переменная
                    this.age = 21; // значение по умолчанию 
                    
                    function foo(name) { 
                      return 'Age ' + name + ' is : ' 
                    }; // это вспомогательная функция
                    
                    this.burn = function() { 
                      return foo(this.name) + (year - this.age) 
                    }; //это метод обькта что на выходе 
                  }; 
                  
                  let Ann = new People; 
                  Ann.name = 'Anna'; 
                  Ann.age = 32; 
                  
                  console.log(Ann.burn()); //вызов метода 
                  console.log(Ann);
                  //People {age: 32, burn: ƒ, name: "Anna"}
                  
                  <b>как видно в обьект все локальные переменные и ф-ции не записались</b>
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>1. Локальные переменные Конструктора</legend>
              <blockquote>
                ..
              </blockquote>
              <pre class="code">
                <code>
                  <b>как видно в обьект все локальные переменные и ф-ции не записались</b>
                </code>
              </pre>
            </fieldset>
            <!-- end 3 -->
          </li>
          <li id="mark4" class="tabs-content-item">
            <!-- 4 -->
            <div class="sub-title">Main</div>
            <div class="title">Примеры</div>
            <fieldset>
              <legend>Потеря контекста</legend>
              <p>This внутри функции и обьекта exampleObject будет указывать не на этот обьект а на глоб обьект window</p>
              <p>
                из-за того, что в строке var showTitle = exampleObject.showTitle мы получаем ссылку только функцию, и при вызове showTitle()
                нет ссылки на исходный объект exampleObject, отчего this начинает ссылаться на объект window.
              </p>
              <pre class="code">
                <code>
                  var title = "Global Title"; 
                  var exampleObject = { 
                    "title": "Example Title", 
                    "showTitle": function(){ 
                      alert(this.title);
                    } 
                  }; 
                  
                  var showTitle = exampleObject.showTitle; // вначале забираем ссылку на функцию
                  showTitle(); // а тут вызываем функцию без ссылки на объект
                </code>
              </pre>
            </fieldset>
            <!-- end 4 -->
          </li>
          <li id="mark5" class="tabs-content-item">
            <!-- 5 -->
            <div class="sub-title">Main</div>
            <div class="title">arguments - псевдомассив аргументов в функциях</div>
            <fieldset>
              <legend>1. Arguments</legend>
              <p class="sub-title">arguments[0], arguments[1]</p>
              <h3>Когда мы не предаем аргуметы изначально</h3>
              <pre class="code">
                <code>
                  function sayHi() { 
                    for (var i = 0; i < arguments.length; i++) { 
                      alert( "Привет, " + arguments[i] ); 
                    } 
                  } 
                  sayHi( "Винни", "Пятачок"); // 'Привет, Винни', 'Привет, Пятачок'
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>2. Массив аргументов</legend>
              <h3>Мы можем создать массив из аргументов</h3>
              <pre class="code">
                <code>
                  var args = []; 
                  for (var i = 0; i < arguments.length; i++) { 
                    args[i] = arguments[i]; 
                  };
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>3. Вызов аргументов в самой функции</legend>
              <h3>В этой функции на момент ее написания мы еще не передали аргументы</h3>
              <pre class="code">
                <code>
                   function func1() { 
                     console.log(arguments[0]); // 1 
                     console.log(arguments[1]); // 2 
                     console.log(arguments[2]); // 3 
                     console.log(arguments[3]); // undefined 
                    } 
                    
                    func1(1, 2, 3);
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>4. Вызов аргументов в самой функции</legend>
              <h3>В этой функции на момент ее написания мы еще не передали аргументы</h3>
              <pre class="code">
                <code>
                   function func1() { 
                     console.log(arguments[0]); // 1 
                     console.log(arguments[1]); // 2 
                     console.log(arguments[2]); // 3 
                     console.log(arguments[3]); // undefined 
                    } 
                    
                    func1(1, 2, 3);
                </code>
              </pre>
            </fieldset>
            <!-- end 5 -->
          </li>
          <li id="mark6" class="tabs-content-item">
            <!-- 6 -->
            <div class="sub-title">Main</div>
            <div class="title">Get/Set/Decriptor свойств</div>
            <fieldset>
              <legend>1. Задать функцию аргументом в свойстве обьекта</legend>
              <pre>
                <code>
                  Они нужны для ограничения доступа извне, также с их помощью можно обычное свойство превратить в функцию.

                  Object.defineProperty(obj, prop, descriptor)
                </code>
              </pre>
              <blockquote>
                <b>obj</b> Объект, в котором объявляется свойство. 
                <b>prop</b> Имя свойства, которое нужно объявить или модифицировать. 
                <b>descriptor</b> Дескриптор – объект, который описывает поведение свойства. В нём могут быть следующие поля: 
                <ol>
                  <li>
                    value |или| get/set – значение свойства, по умолчанию undefined
                  </li>
                  <li>
                    writable |или| get/set – значение свойства можно менять, если true. По умолчанию false.
                  </li>
                  <li>
                    configurable – если true, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов defineProperty. По умолчанию false.</li>
                  <li>
                    enumerable – если true, то свойство просматривается в цикле for..in и методе Object.keys(). По умолчанию false.
                  </li>
                  <li>
                    get – функция, которая возвращает значение свойства. По умолчанию undefined.
                  </li>
                  <li>
                    set – функция, которая записывает значение свойства. По умолчанию undefined.
                  </li>
                </ol>    
              </blockquote>
              <pre>
                Object.defineProperty(obj, prop, descriptor)
              </pre>
              <blockquote>
                get - считывает 
                set - записывает что нужно с ним зделать
              </blockquote>
              <pre class="code">
                <code>
                  var user = { 
                    firstName: "Вася", 
                    surname: "Петров", 
                    
                    get fullName() { 
                      return this.firstName + ' ' + this.surname; 
                    }, 
                    set fullName(value) { 
                      var split = value.split(' '); 
                      this.firstName = split[0]; 
                      this.surname = split[1]; 
                    } 
                  }; 
                  alert( user.fullName ); // Вася Петров (из геттера) 
                  
                  user.fullName = "Петя Иванов"; 
                  alert( user.firstName ); // Петя (поставил сеттер) 
                  alert( user.surname ); // Иванов (поставил сеттер)
                </code>
              </pre>
            </fieldset>
            <!-- end 6 -->
          </li>
          <li id="mark7" class="tabs-content-item">
            <!-- 7 -->
            <div class="sub-title">Main</div>
            <div class="title">Рекурсия - ф-я вызывает саму себя</div>
              <fieldset>
                <legend>2. Рекурсия</legend>
                <h5><b>Peкурсия</b> - это когда в выполнение функции заложено выполнять саму себя n к-во раз как в примере со
                  степенью числа.</h5>
                <blockquote>
                  Говорят, что «функция pow рекурсивно вызывает сама себя» до n == 1. Значение, на котором рекурсия заканчивается,
                  называют
                  базисом рекурсии. pow(x, n) = x * pow(x, n - 1) x - число; n - степень
                  <ol>Например, вычислим pow(2, 4), последовательно переходя к более простой задаче:
                    <li>pow(2, 4) = 2 * pow(2, 4)</li>
                    <li>pow(2, 3) = 2 * pow(2, 3)</li>
                    <li>pow(2, 3) = 2 * pow(2, 2)</li>
                    <li>pow(2, 3) = 2 * pow(2, 1)</li>
                  </ol>
                  При выполнении pow(2, 1), в отличие от предыдущих запусков, выражение n != 1 будет равно false, поэтому сработает
                  else гле
                  х == самому числу
                </blockquote>
                <pre class="code">
                  <code>
                    function pow(x, n) { 
                      if (n != 1) { 
                        // пока n != 1, сводить вычисление pow(x,n) к pow(x,n-1) 
                        return x * pow(x, n - 1); 
                      } else { 
                        return x; 
                      } 
                    } 
                    
                    alert( pow(2, 3) ); // 8
  
                    <b>Вариант с циклом намного экономнее</b>
                    let quoxx = function(x,y) { 
                      let foo = x; 
                      for (; y >= 1; y--) { 
                        foo *= x; 
                      } 
                      return foo; 
                    } 
                    quoxx(2, 4)
                  </code>
                </pre>
              </fieldset>
            <!-- end 7 -->
          </li>
          <li id="mark8" class="tabs-content-item">
            <!-- 8 -->
            <div class="sub-title">Main</div>
            <div class="title">Стек</div>
         
            <!-- end 8 -->
          </li>

        </ul>
      </div>
    </div>
  </div>

  <script src="../../js/main/hilight.js"></script>
  <script src="../../js/main/dynamic.js"></script>
  <script src="../../js/main/main.js"></script>

</body>

</html>