<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.1/css/all.css" integrity="sha384-O8whS3fhG2OnA5Kas0Y9l3cfpmYjapjI0E4theH4iuMD+pLhbf6JI0jIMfYcK3yZ"
    crossorigin="anonymous">
  <link rel="stylesheet" href="../../css/style.css">
</head>

<body>
  <div class="nav">
    <div id="bread-crumps"></div>
    <div class="search">
      <span>&#64;</span>
      <input type="text">
      <button>search</button>
    </div>
  </div>
  <div class="header">
    <div id="menu"></div>
  </div>
  <div class="content">

    <div class="info">
      <div class="info-left">
        <h4 class="links-themes-title">Разные практики</h4>
        <!-- TABS NAV-->
        <ul class="tabs-nav-list">
          <li class="tabs-nav-item active" onclick="openMark(event,'mark1')">Интерессный код</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark2')">Main.js</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark3')">Dynamic.js</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark4')">Оптимизация</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark5')">Асинк. Таймеры</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark6')">Асинк. Стек</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark7')">Асинк. Promises</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark8')">async / await</li>
        </ul>
        <!-- END NAV -->
      </div>
      <div class="info-right">
        <div id="extra-menu" class="links-themes-list"></div>
        <ul class="tabs-content-list info-right-content">
          <li id="mark1" class="tabs-content-item active">
            <!-- 1 -->
            <div class="sub-title">Main</div>
            <div class="title">Прикольные практики или просто красивый код</div>
            <fieldset>
              <legend>
                1. Интерессные способы передачи данных в JS
              </legend>
              <pre class="code">
                <code>
                  <b>Название ф-ции</b>
                  ["test".toUpperCase()]() { 
                    alert("PASSED!"); 
                  }

                  <b>если нету else и условие достаточно короткое</b>
                  if(y === undefined) y = 5;  
                  
                  <b>короткая запись if-else</b>
                  (y === undefined) ? (do...) : (else do ...)
                  
                  <b>1 2 3 отображает содержание массива</b>
                  mass == [1,2,3]; ...mass   
                  
                  <b>//true</b>
                  func(...mass) == func(1,2,3)
                  ...(три точки) можно передавать массив в качестве параметров функции 
                  
                  <b>else можно вписать и в переменную</b>
                  var x = v || 10

                  <b>if else тоже можно вписать в переменную</b>
                  var direction = (x > 100) ? 1 : -1;

                  <b>Преобразование функции в обьект можно тут же ее вызвав</b>
                  new Menu(menu);
                  
                  <b>Превратить массив в строку и положить каждый елемент на кавычки</b>
                  '"' + [1,2,3].join('", "') + '"'

                  <b>Вставить в строку переменную</b>
                  alert(`Starting my ${subject} homework.`);
                </code>
              </pre>
            </fieldset>
            <!-- end 1 -->
          </li>
          <li id="mark2" class="tabs-content-item">
            <!-- 2 -->
            <div class="sub-title">Main</div>
            <div class="title">Main.js</div>
            <fieldset>
              <legend>1. Div function</legend>
              <blockquote>Эта функция создает div с информацией внутри. 
                Принимает 4 параметра:
                <ul>
                  <li>str - передаваемая строка</li>
                  <li>location - расположение</li>
                  <li>cleaner - убирает старый результат</li>
                  <li>lable - убирает текст "ваш результат"</li>
                </ul>
              </blockquote>
              <pre class="code">
                <code>
                  function div(str, location, cleaner, lable) { 
                    let divEl = document.createElement('div'); 
                    let text = 'Ваш результат: ' + '<br/>'; 
                    if (lable != true) { 
                      text = ''; 
                    } 
                    divEl.style.transition = 0.5 + "s"; 
                    divEl.className = "includer"; 
                    divEl.innerHTML = text + str; 
                    
                    if (cleaner == true) { 
                      empty(location); //вызов функции чистильщика
                      //oна удаляет все дивы кроме одного
                    } 
                    
                    if (location !== undefined) { 
                      location.appendChild(divEl) 
                    } else { 
                      document.body.appendChild(divEl) 
                    } 
                  }
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>2. Create table</legend>
              <blockquote>
                Заносит массив mass в табличку, котору создает в elem
              </blockquote>
              <pre class="code">
                <code>
                function dispArr(mass, elem) { 
                  let table = document.createElement('table'), 
                  tr = document.createElement('tr');
                  elem.parentElement.insertBefore(table, elem); 
                  table.appendChild(tr); 
                  for (let i = 0; i < mass.length; i++) { 
                    let td=document.createElement('td'); 
                    tr.appendChild(td); 
                    td.innerHTML=mass[i]; 
                  } 
                };
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>3. Маленькие, но очень полезные ф-ции</legend>
              <pre class="code">
                <code>
                  <b>Удаляет всех потомков в теге</b>
                  function empty(wrap) { 
                    while (wrap.children.length > 0) { 
                      wrap.removeChild(wrap.lastChild); 
                    } 
                  };

                  <b>Сортирует числа</b>
                  function compareNumbers(a, b) { 
                    return a - b; 
                  } 
                  
                  <b>Случайное число</b> 
                  function getRandom(min, max) { 
                    return Math.floor(Math.random() * (max - min) + min); 
                  }

                  <b>флаг. Наличия элемента в массиве</b>
                  function hasElem(mass, num) { 
                    for (let i = 0; i < mass.length; i++) { 
                      if (num==m ass[i]) { 
                        return true; 
                      } 
                    } 
                    return false; 
                  };

                  <b>Получить случайное число из массива</b>
                  function randNumArr(arr) { 
                    return arr[Math.floor(Math.random() * arr.length)]; 
                  };
                </code>
              </pre>
            </fieldset>
            <!-- end 2 -->
          </li>
          <li id="mark3" class="tabs-content-item">
            <!-- 3 -->
            <div class="sub-title">Main</div>
            <div class="title">Dynamic.js</div>
            <fieldset>
              <legend>1. Формат JSON скриптового меню</legend>
              <blockquote>Ниже скрипт который будет его парсить</blockquote>
              <pre class="code">
                <code>
                  var JSON = { 
                    menu: [ 
                      { title: 'Module 1', submenu: [ 
                        { linkname: '1. logic, drawing', link: '../practice/lesson1.html'},
                        { linkname: '2. Рекурсия', link: '../practice/lesson2.html'}, 
                        { linkname: '3. empty yet', link: '../practice/lesson3.html'}
                      ] }, 
                      { title: 'Module 2', submenu: [ 
                        { linkname: '11. random, sort', link: '../practice/lesson10.html' }, 
                        { linkname: '12. this', link: '../practice/lesson11.html' }, 
                        { linkname: '13. array', link: '../practice/lesson12.html' }
                      ] } 
                    ], 
                    breadcrumps: [ 
                      { linkname: 'i class="fas fa-home"',link: '../index.html'}, 
                      { linkname: 'i class="fas fa-home"',link: '../index.html'}, 
                      { linkname: 'i class="fas fa-home"',link: '../index.html'}
                    ], 
                    extramenu: [ 
                      { linkname: 'dom',link: '#'}, 
                      { linkname: 'history',link: '#'},
                      { linkname: 'preforences',link: '#'}
                    ] 
                  };
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>2. Меню парсинг json</legend>
              <blockquote>Ниже скрипт который будет его парсить</blockquote>
              <pre class="code">
                <code>
                  parseDom(document.getElementById('menu'), JSON.menu);

                  if (breadcrumps) {
                    parseDom(breadcrumps, JSON.breadcrumps);
                  }

                  if (extramenu) {
                    parseDom(extramenu, JSON.extramenu);
                  }
                  
                  function parseDom(elem, parse) { 
                    let ul = document.createElement('ul'); 
                    elem.appendChild(ul); 

                    for(let i = 0; i < parse.length; i++) { 
                      let a=document.createElement('a'), 
                      h5=document.createElement('h5'), 
                      li=document.createElement('li'); 
                      
                      ul.appendChild(li);
                    
                      if(parse[i].title) { 
                        li.appendChild(h5);
                        h5.innerHTML=parse[i].title; 
                      }; 
                      
                      if(parse[i].linkname) { 
                        li.appendChild(a); 
                        a.innerHTML=parse[i].linkname; 
                        a.setAttribute('href', parse[i].link); 
                      }; 
                      
                      if(parse[i].submenu) { 
                        parseDom(li, parse[i].submenu) 
                      }; 
                    } 
                    hljs.initHighlightingOnLoad();
                  };                 
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>3. Collapse menu in header</legend>
              <blockquote>Закрыть раскрыть меню</blockquote>
              <pre class="code">
                <code> 
                  for (let i = 0; i < menu.querySelectorAll('h5').length; i++) {    
                    menu.querySelectorAll('h5')[i].addEventListener('click', function () { 
                      if (menu.className != 'active' ) { 
                        menu.className = 'active'; 
                      } else { 
                        menu.className = ''; 
                      } 
                    }); 
                  };
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>3. Tabs</legend>
              <blockquote>Табы aside</blockquote>
              <pre class="code">
                <code> 
                  function openMark(evt, mark) { 
                    window.scrollTo(0,80); 
                    window.addEventListener('scroll', unstickAside); 

                    let nav = document.getElementsByClassName('tabs-nav-item'), 
                        content = document.getElementsByClassName('tabs-content-item'); 
                    
                    for (let i = 0; i < nav.length; i++) { 
                      nav[i].className=nav[i].className.replace(' active', ''); 
                      content[i].className=content[i].className.replace(' active', ''); 
                    }; 
                    
                    evt.currentTarget.className +=' active' ; 
                    document.getElementById(mark).className +=' active' ; 
                  };
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>4. Sticky Aside</legend>
              <blockquote>При прокрутке приклеивает aside</blockquote>
              <pre class="code">
                <code> 
                  let sticky = { 
                    elem: document.getElementsByClassName('tabs-nav-list')[0], 
                    mt: function() { 
                      return this.elem.getBoundingClientRect().top;
                    }, 
                    stick: function() { 
                      return this.mt() 
                    }, 
                  }; 
                  
                  function stickAside() { 
                    let offsetCollapseMenu = 227; 
                    let offsetOpenMenu = 477; 
                    let marginTop = 50; 
                    sticky.elem.style.position = 'fixed'; 
                    
                    if (menu.className != 'active') { 
                      if (window.pageYOffset < offsetCollapseMenu - marginTop) {       
                        window.removeEventListener('scroll', stickAside); 
                        window.addEventListener('scroll', unstickAside);
                      } 
                    } else { 
                      if (window.pageYOffset < offsetOpenMenu - marginTop) { 
                        window.removeEventListener('scroll', stickAside); 
                        window.addEventListener('scroll', unstickAside); 
                      } 
                    } 
                  }; 
                  
                  function unstickAside() { 
                    sticky.elem.style.position='relative'; 
                    if (sticky.mt() < marginTop) {
                      window.addEventListener('scroll', stickAside); 
                      window.removeEventListener('scroll', unstickAside); 
                    } 
                  }; 
                  
                  window.addEventListener('scroll', unstickAside); 
                  
                  if (sticky.elem) sticky.stick; 
                  
                </code>
              </pre>
            </fieldset>
            <!-- end 3-->
          </li>
          <li id="mark4" class="tabs-content-item">
            <!-- 4 -->
            <div class="sub-title">Main</div>
            <div class="title">Оптимизация странички</div>
            <fieldset>
              <legend>1. Когда много картинок</legend>
              <blockquote>
                Мы меняем все картинки на серые квадраты. grey gif 1x1<br>
                В realsrc лежит настоящий src. <br><br>
                Код при прокрутке окна загружает ставшие видимыми изображения. 
                То есть, как только изображение попало в видимую часть документа – в src нужно прописать правильный URL из realsrc.
              </blockquote>
              <pre>
                  <b>Заменяем такую картинку</b>
                  img src="yozhik.jpg" width="128" height="128">
                  <b>На такую</b>
                  img src="1.gif" width="128" height="128" realsrc="yozhik.jpg">
              </pre>
              <br>
              <pre class="code">
                <code>
                  let imgs = document.getElementsByTagName('img'); 
                  let winH = window.innerHeight; 
                  
                  for(let i=0; i < imgs.length; i++) { 
                    if (imgs[i].offsetTop < winH) { 
                      let fooSrc=imgs[i].getAttribute('src'); 
                      let trueSrc=imgs[i].getAttribute('realsrc'); 
                      imgs[i].setAttribute('src', trueSrc); 
                    } 
                  } 
                  
                  window.onscroll=function() { 
                    let pageScrl=window.pageYOffset; 
                    let elScrl=imgs[4].getBoundingClientRect().x;
                        
                    for(let i=0; i < imgs.length; i++) { 
                      if (pageScrl==imgs[i].getBoundingClientRect().x) { 
                        let fooSrc=imgs[i].getAttribute( 'src'); 
                        let trueSrc=imgs[i].getAttribute( 'realsrc'); 
                        imgs[i].setAttribute( 'src', trueSrc);
                        } 
                      } 
                    }
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>2. </legend>
              <blockquote>///</blockquote>
              <pre class="code">
                <code>
                          
                </code>
              </pre>
            </fieldset>
            <!-- end 4 -->
          </li>
          <li id="mark5" class="tabs-content-item">
            <!-- 5 -->
            <div class="sub-title">Main</div>
            <div class="title">Асинхронность. Таймеры</div>
            <fieldset>
              <legend>1. Таймеры.</legend>
              <blockquote>
                Однопоточная модель - чтобы на один элемент не воздействовало одновременно два потока

                Cуть в том что сначала код должен полностью загрузится, 
                а timeout сработает сразу если он просрочен.
                Интерпретатор пробежится по нашему коды вплодь по последней строки.
                и все задачи станут в очередь
              </blockquote>
              <pre>
                setTimeout(function(){
                  console.log('timeout 3000')}, 3000) 
                    // после чтения основного кода, включая for на 2 сек. 
                    // этот код выполнится через 1 сек после загрузки
              
                setTimeout(function(){
                    console.log('timeout 1000')}, 1000) 
                    // этот код сработает мгновенно сразу после загрузки
                
                for (let i = 0; i < 2000000000; i++) {} 
                    // эта операция загрузит интерпретатор на 2 сек
                
                console.log('after for'); 
                    // эта строка должна выполнится мгновенно после того как странится загрузится
                <b>Если немного поменять порядок выполнения</b>
                console.log('after timeout 1000') // выполнится мгновенно
                setTimeout(function(){
                  console.log('before timeout 1000') // через 1 сек(это наш таймер)
                  for (let i = 0; i < 2000000000; i++) {} // эта операция загрузит интерпретатор на 2 сек
                  console.log('after timeout 1000') // и еще через 2 сек(так как for загрузит процесс выполнения на 2 сек)
                }, 1000)
              </pre>
            </fieldset>
            <!-- end 5 -->
          </li>
          <li id="mark6" class="tabs-content-item">
            <!-- 6 -->
            <div class="sub-title">Main</div>
            <div class="title">Стек</div>
              <fieldset>
                <legend>Стек</legend>
                <h5><b>Стэк</b> - Порядок вызова функций где компьютер запоминает контекст, называется стеком. Будущие и прошедшие
                  итерации в очереди.</h5>
                <ul>
                  n--
                  <li>Контекст: { x: 2, n: 3, строка 1 } // Контекст</li>
                  <li>Контекст: { x: 2, n: 2, строка 2 } // Стек </li>
                  <li>Контекст: { x: 2, n: 1, строка 3 } // Стек </li>
                </ul>
                <blockquote>
                  pow(2, 1) Опять вложенный вызов в строке 3, на этот раз – с аргументами x=2, n=1. Создаётся новый текущий контекст,
                  предыдущий
                  добавляется в стек (в стеке уже два старых контекста) Kаждый раз при вызове функции, текущий контекст помещается
                  наверх
                  стека. Тогда функция возвращается, она забирает верхний контекст из стека и использует его для продолжения работы.
                </blockquote>
              </fieldset>
            <!-- end 6 -->
          </li>
          <li id="mark7" class="tabs-content-item">
            <!-- 7 -->
            <div class="sub-title">Main</div>
            <div class="title">Асинхронность. Промисы</div>
              <fieldset>
                <legend>1. Promises - синтаксис</legend>
                <blockquote>
                  При успешном ответе от сервера выполняем первую ф-цию.
                  При неуспешном ответе выполняем вторую ф-цию.
                </blockquote>
                <blockquote>
                  Вызов delay(2000) создаёт промис, который будет разрешён через 2000 мс., затем мы возвращаем этот промис из
                  коллбэка
                  успешного завершения операции в первом then(…), что приводит к тому, что промис второго then(…) будет ожидать эти
                  2000
                  мс.
                </blockquote>
                <pre>
                  sum(fetchX(), fetchY())
                    .then(
                      // обработчик успешного разрешения промиса
                      function(sum) {
                          console.log( sum );
                      },
                      // обработчик отклонения промиса
                      function(err) {
                        
                      console.error( err ); // что-то пошло не так
                    }
                  );
                  <b>Цепочки промисов</b>
                  function delay(time) {
                    return new Promise(function(resolve, reject){
                        setTimeout(resolve, time);
                    });
                  }
                  
                  delay(1000)
                  .then(function(){
                      console.log("after 1000ms");
                      return delay(2000);
                  })
                  .then(function(){
                      console.log("after another 2000ms");
                  })
                  .then(function(){
                      console.log("step 4 (next Job)");
                      return delay(5000);
                  })
  
                </pre>
              </fieldset>
              <fieldset>
                <legend>2. Промисы. Разбор part1(от loft school)</legend>
                <blockquote>
                  При успешном ответе от сервера выполняем первую ф-цию.
                  При неуспешном ответе выполняем вторую ф-цию.
                  state(3 состояния):
                  - Pending - Ожидание 
                  - Resolve (or Fullfilled) - выполнено Успешно
                  - Rejected - выполнено Неудача
                </blockquote>
                <pre class="code">
                  <code>
                    <b>Example 1</b>
                    const promise = { 
                      state: ['pending', 'fullfilled', 'rejected']
                    }
                    
                    <b>Example 2 - мы обращаемся к обьекту Promise и его метод-функция имеет еще две функции успех и неудача</b>
                    const promise = new Promise(function(resolve, reject) {
                      resolve() // мы вызываем успех в нашем Promise
                    })

                    <b>Example 3 - list of functions in one promise</b>
                    const promise = {
                      state: ['pending', 'fullfilled', 'rejected'],
                      queue: [ // in this promise quaio funcs
                        ()=>console.log(1),
                        ()=>console.log(2),
                        ()=>console.log(3)
                      ]
                    }

                    function delay(timer) {
                      return new Promise( resolve=>{
                        setTimeout( ()=> { 
                          resolve() // если поменять на reject() то then не сработают
                          console.log('resolved!');
                        }, timer)
                      })
                    }
                    var promise = delay(2000) //запускаем таймер при успешном выполнении
                    promise.then(()=>console.log(1)) // при успешном выполнении. 
                    promise.then(()=>console.log(2)) // Запускается цепь промисов f1,f2,f3
                    promise.then(()=>console.log(3))

                    <b>Example 4 - chains promises. One function - one promise. </b>
                      const promise = {
                        state: ['fullfilled'],
                        queueResolved: [ // promise 1
                          ()=>console.log(1)
                        ]
                      }
                      const promise = {
                        state: ['fullfilled'],
                        queueResolved: [ // promise 2   
                          ()=>console.log(2)
                        ]
                      }
                      const promise = {
                        state: ['fullfilled'],
                        queueResolved: [ // promise 3
                          ()=>console.log(3)
                        ]
                      }

                      function delay(timer) {
                      return new Promise( resolve=>{
                        setTimeout( ()=> { 
                          resolve() // если поменять на reject() то then не сработают
                          console.log('resolved!');
                        }, timer)
                      })
                    }

                    var promise = delay(2000) //запускаем таймер при успешном выполнении

                    promise
                        .then(()=>console.log(1)) // при успешном выполнении. 
                        .then(()=>console.log(2)) // Запускается цепь промисов f1,f2,f3
                        .then(()=>console.log(3))
                  </code>
                </pre>
              </fieldset>
              <fieldset>
                <legend>3. Промисы. Разбор part2</legend>
                <blockquote>
               
                </blockquote>
                <pre class="code">
                  <code>

                  </code>
                </pre>
              </fieldset>
            <!-- end 7 -->
          </li>
          <li id="mark8" class="tabs-content-item">
            <!-- 8 -->
            <div class="sub-title">Main</div>
            <div class="title">Асинхронность. Промисы</div>
              <fieldset>
                <legend>...</legend>
                <blockquote>
                  При успешном ответе от сервера выполняем первую ф-цию.
                  При неуспешном ответе выполняем вторую ф-цию.
                </blockquote>
                <pre>
                
                </pre>
              </fieldset>
            <!-- end 7 -->
          </li>
        </ul>
      </div>
    </div>
  </div>

  <script src="../../js/main/hilight.js"></script>
  <script src="../../js/main/dynamic.js"></script>
  <script src="../../js/main/main.js"></script>

</body>

</html>