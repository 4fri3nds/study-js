<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.1/css/all.css" integrity="sha384-O8whS3fhG2OnA5Kas0Y9l3cfpmYjapjI0E4theH4iuMD+pLhbf6JI0jIMfYcK3yZ"
    crossorigin="anonymous">
  <link rel="stylesheet" href="../../css/style.css">
</head>

<body>
  <div class="nav">
    <div id="bread-crumps"></div>
    <div class="search">
      <span>&#64;</span>
      <input type="text">
      <button>search</button>
    </div>
  </div>
  <div class="header">
    <div id="menu"></div>
  </div>
  <div class="content">

    <div class="info">
      <div class="info-left">
        <h4 class="links-themes-title">Object</h4>
        <!-- TABS NAV-->
        <ul class="tabs-nav-list">
          <li class="tabs-nav-item active" onclick="openMark(event,'mark1')">Применение</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark2')">Методы</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark3')">Код</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark4')">Get,Set</li>
        </ul>
        <!-- END NAV -->
      </div>
      <div class="info-right">
        <div id="extra-menu" class="links-themes-list"></div>
        <ul class="tabs-content-list info-right-content">
          <li id="mark1" class="tabs-content-item active">
            <!-- 1 -->
            <div class="sub-title">Main</div>
            <div class="title">Обьекты и их использование</div>
            <fieldset>
              <legend>1. Object</legend>
              <h3>ОБЬЕКТЫ – это ассоциативные массивы</h3>
              <pre>
                <code>
                  <b>Обратится</b>
                  obj.key -- обратится к свойству обьекта
                  user.size.top -- более глубокое свойство
                  obj[key] -- обратится к свойству обьекта
                  <i>Доступ через точку используется, если мы на этапе написания программы уже знаем название свойства. А если оно будет определено по ходу выполнения, например, введено посетителем и записано в переменную, то единственный выбор – квадратные скобки.</i>
                  
                  <b>Получить значения</b>
                  Object.keys(obj) -- Получить значения обьекта
                  
                  <b>Удалить</b>
                  delete person.age -- удалить age из обьекта obj
                  
                  <b>Перебрать</b>
                  for (var key in menu) { ... } 
                  -- for..in -- При этом for..in последовательно переберёт свойства объекта obj, имя каждого свойства будет записано в key
                  
                  <b>более короткий перебор -- !! стоит попробовать</b>
                  Object.keys(menu).length
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>2. Копирование обьекта. Метод copy(1,2,3)</legend>
              <pre>
                <code>
                  <h4>Скопировать свойства метод - copy()</h4>
                  test2=new Object() тоже что test = {};
                  
                  <h4>Копирует свойства из объектов src1, src2,... в объект dst</h4>
                  copy(dst, src1, src2…)
                
                  <b>Пример</b>
                  var vasya = { age: 21, name: 'Вася', surname: 'Петров' }; 
                  var user = { isAdmin: true, isEmailConfirmed: true }; 
                  var student = { university: 'My university' }; 
                  
                  <h5>//скопирует все свойства</h5>
                  copy(vasya, user, student);
                  
                  alert( vasya.isAdmin); // true
                  alert( vasya.university ); // My university
                  
                  <h5>//вставить скопированные свойства в пустой объект</h5>
                  var userClone = copy({}, user);
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>3. Проверка на свойство</legend>
              <h3>Проверить на наличие нужно свойства в обьекте</h3>
              <p>проверить существование свойства – получив его и сравнив с undefined:</p>
              <pre>
                <code>
                  var person = { name: "Василий" }; 
                  alert( person.lalala === undefined ); // true, свойства нет 
                  alert( person.name === undefined); // false, свойство есть.
                </code>
              </pre>
              <p>проверить существование свойства – оператором undefined:</p>
              <pre>
                <code>
                  var obj = {}; 
                  obj.test = undefined; 
                  alert( "test" in obj ); // true 
                  alert( "blabla" in obj ); // false
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>4. Функции и обьекты в обьекте</legend>
              <p>
                В обьектах могут находится как другие обьекты - так и функции. В функиях this будет ссылка на обьект в котором она используется.
              </p>
              <pre class="code">
                <code>
                  <b>result: Hello, Петя.</b>        
                  test = { 
                    simple_property: 'Hello', 
                    object_property: { 
                      user_1: 'Петя', 
                      user_2: 'Вася' 
                    }, 
                    function_property: function(user) { 
                    alert(this.simple_property + ', ' + this.object_property[user]); 
                  } 
                } 
                test.function_property('user_1'); //Hello, Петя.
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>5. Методы обьектов</legend>
              <blockquote>
                Это функции в обьекте. И судя по тому что доступ они имеют только к свойствам этого обьекта они изолированые от глобальной видимости.
              </blockquote>
              <pre class="code">
                <code>
                  <b>result: Hello, Петя.</b>        
                   let MyApp = { 
                     name: 'Max', 
                     age: 12, 
                     size: 3, 
                     sayName: function(name) { 
                       return console.log("Hello " + name.toUpperCase())
                      }, 
                     sayPreved: function() { 
                      return this.sayName(this.name) 
                    } 
                  } 
                  
                  MyApp.sayPreved()
                  <b>дописать отдельно метод</b>
                  <blockquote>Большым плюсом является доступ this к обьекту и его свойствам</blockquote>
                  MyApp.sayPreved = function() {
                    return this.sayName(this.name);
                  }
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>6. Правописание переменных, ф-й, м-в</legend>
              <blockquote>
                Это функции в обьекте. И судя по тому что доступ они имеют только к свойствам этого обьекта они изолированые от глобальной видимости.
              </blockquote>
              <pre>
                <code>
                  <b>Для методов: Get - Set</b>        
                   // плохо dragon.age(); 
                   // хорошо dragon.getAge(); 
                   // плохо dragon.age(25); 
                   // хорошо dragon.setAge(25);

                  <b>Для Boolean: Is - Has</b>
                    // плохо if (!dragon.age()) { 
                     return false; 
                    } 
                    // хорошо if (!dragon.hasAge()) { 
                      return false; 
                    }
                </code>
              </pre>
            </fieldset>
            <!-- end 1 -->
          </li>
          <li id="mark2" class="tabs-content-item">
            <!-- 2 -->
            <div class="sub-title">Main</div>
            <div class="title">Методы обьектов</div>
            <fieldset>
              <legend>1. Методы обьектов MUST TO KNOW</legend>
              <pre>
                <code>
                  <b>Object.keys</b> - ключи - значение свойств. Объекта в виде массива. // 
                  <b>Object.values</b> - свойства объекта в виде массива. // 
                  <b>hasOwnProperty</b> - проверяет, принадлежит ли "НАЗВАНИЕ СВОЙСТВА" самому объекту или нет. user.hasOwnProperty('toString') // false
                  
                  <b>сonstructor</b> - содержит ссылку на конструктор, которым объект был создан. obj.constructor // function Constr() {}
                  <b>Object.entries(obj)</b> - Создает многомерный массив k-ключь v-значение
                  [[k:v],[k:v]]

                  <b>valueOf</b> - преобразовать обьект в функцию, которая возвращает число.
                  <b>toString</b> - преобразовать обьект в функцию, которая возвращает строку.

                  <b>defineProperty</b> - позволяет установить правила на одно! свойство обьекта
                  <b>defineProperties</b> - позволяет установить правила на несколько свойств обьекта
                  
                  <b>Object.create</b> - позволяет узнать принадлежит ли объект классу или классу наследующему от него.
                  <b>instanceof</b> - позволяет узнать принадлежит ли объект классу или классу наследующему от него. fnObj instanceof FnConstructor // true
                  
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>2. defineProperty(ies)</legend>
              <blockquote>
                Метод Object.defineProperty - позволяет устанавливать свойствам некоторые настройки (можно ли свойство изменять, удалять и др.)
                <hr>
                Дескриптор - это объект, который описывает поведение свойства. В нем могут быть следующие свойства:
              </blockquote>
              <ul>
                <li>
                  <b>value</b> //значение свойства (undefined)
                </li>
                <li>
                  <b>writable</b> //если true - свойство можно перезаписывать (false)
                </li>
                <li>
                  <b>configurable</b> // если true, то свойство можно удалять (false)
                </li>
                <li>
                  <b>enumerable</b> //если true, то свойство видно в цикле for..in (false)
                </li>
                <li>
                  <b>get</b> //Функции, которая возвращает значение свойства (undefined)
                </li>
                <li>
                  <b>set</b> //Функции, которая записывает значение свойства (undefined);
                </li>
              </ul>
              <pre class="code">
                <code>
                  <b>для defineProperty - одно значение</b>
                    Object.defineProperty(объект, 'имя свойства', дескриптор);
                  <b>для defineProperties - много значений</b>
                  var obj = {
                    val1: 10, //Обычное свойство
                  }
                  
                  Object.defineProperties(obj, {
                    val2: {
                      value: 20,
                      configurable: false,
                    },
                    val3: {
                      value: 30,
                      configurable: false,
                    }
                  });
                  
                  alert(obj.val1) //10
                  alert(obj.val2) //20
                  alert(obj.val3) //30
                  
                  delete obj.val1
                  delete obj.val2
                  delete obj.val3
                  
                  alert(obj.val1) //undefined
                  alert(obj.val2) //20
                  alert(obj.val3) //30
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>3. obj.constructor</legend>
              <blockquote>
                Когда мы переназначаем функцию на обьект через NEW. Мы можем узнать из какой функции вышел этот обьект с помощью .constructor
              </blockquote>
              <pre class="code">
                <code>
                  function FnConstructor() { this.bar = 1 }
                  let fnObj = new FnConstructor();
                  fnObj.constructor // function FnConstructor() { this.bar = 1 }
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>4. obj.constructor</legend>
              <blockquote>
                Когда мы переназначаем функцию на обьект через NEW. Мы можем узнать из какой функции вышел этот обьект с помощью .constructor
              </blockquote>
              <pre class="code">
                <code>
                  function FnConstructor() { this.bar = 1 }
                  let fnObj = new FnConstructor();
                  fnObj.constructor // function FnConstructor() { this.bar = 1 }
                </code>
              </pre>
            </fieldset>
            <!-- end 2 -->
          </li>
          <li id="mark3" class="tabs-content-item">
            <!-- 3 -->
            <div class="sub-title">Main</div>
            <div class="title">Код</div>
            <fieldset>
              <legend>1. Переиспользование обьекта</legend>
              <p>Если объект, нужно переиспользовать то удобнее будет сделать отдельную функцию, возвращающую объект</p>
              <pre class="code">
                <code>
                  function getDog(name, age){ 
                    return { 
                      "name": name, 
                      "age": age, 
                      "talk": function(){ 
                        alert('Name: ' + this.name + ', Age: ' + this.age); 
                      } 
                    }; 
                  } 
                  var rocky = getDog('Rocky', 5); 
                  var jerry = getDog('Jerry', 3);
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>2. Так можно заводить новые значения в обьекты </legend>
              <pre class="code">
                <code>
                  let x = 111;
                  undefined
                  let obj1 = {a:x}
                  undefined
                  obj1
                  {a: 111}
                  let y = 222
                  undefined
                  let z = 333
                  undefined
                  obj = { x1 : y, x2 : z }
                  {x1: 222, x2: 333}
                  obj
                  {x1: 222, x2: 333}
                  obj = { x, y, z }
                  {x: 111, y: 222, z: 333}
                </code>
              </pre>
            </fieldset>
            <!-- end 3-->
          </li>
          <li id="mark4" class="tabs-content-item">
            <!-- 4 -->
            <div class="sub-title">Main</div>
            <div class="title">Геттеры, Сеттеры</div>
            <fieldset>
              <legend>1. Дескрипторы</legend>
              <blockquote>Основной метод для управления свойствами – Object.defineProperty. Он позволяет объявить свойство объекта и, что самое главное,
              тонко настроить его особые аспекты, которые никак иначе не изменить.</blockquote>
              <pre><code>
                <b>Синтаксис:</b>Object.defineProperty(obj, prop, descriptor)
                 
                <b>obj</b> Объект, в котором объявляется свойство. 
                <b>prop</b> Имя свойства, которое нужно объявить или модифицировать. 
                <b>descriptor</b> Дескриптор – объект, который описывает поведение свойства.
              </code></pre>

              В нём могут быть следующие поля:
              <ul style="list-style-type: disc;">
                <li><b>value</b> – значение свойства, по умолчанию undefined</li>
                <li><b>writable</b> – значение свойства можно менять, если true. По умолчанию false.</li>
                <li><b>configurable</b> – если true, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов defineProperty.
                По умолчанию false.</li>
                <li><b>enumerable</b> – если true, то свойство просматривается в цикле for..in и методе Object.keys(). По умолчанию false.</li>
                <li><b>get</b> – функция, которая возвращает значение свойства. По умолчанию undefined.</li>
                <li><b>set</b> – функция, которая записывает значение свойства. По умолчанию undefined.</li>
              </ul>
              <br>
              <h4>Два таких вызова работают одинаково:</h4>
              <pre class="code">
                <code>
                   var user = {};
                   <b>1. простое присваивание</b> 
                   user.name = "Вася"; //
                   <b>2. указание значения через дескриптор</b> 
                    Object.defineProperty(user, "name", { 
                      value: "Вася", 
                      configurable: true, 
                      writable: true, 
                      enumerable: true 
                    });
                </code>
              </pre>
            </fieldset>
            <!-- end 4-->
          </li>
        </ul>
      </div>
    </div>
  </div>

  <script src="../../js/main/hilight.js"></script>
  <script src="../../js/main/dynamic.js"></script>
  <script src="../../js/main/main.js"></script>

</body>

</html>