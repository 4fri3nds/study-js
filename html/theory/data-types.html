<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.1/css/all.css" integrity="sha384-O8whS3fhG2OnA5Kas0Y9l3cfpmYjapjI0E4theH4iuMD+pLhbf6JI0jIMfYcK3yZ"
    crossorigin="anonymous">
  <link rel="stylesheet" href="../../css/style.css">
</head>

<body>
  <div class="nav">
    <div id="bread-crumps"></div>
    <div class="search">
      <span>&#64;</span>
      <input type="text">
      <button>search</button>
    </div>
  </div>
  <div class="header">
    <div id="menu"></div>
  </div>
  <div class="content">

    <div class="info">
      <div class="info-left">
        <h4 class="links-themes-title">Типы данных</h4>
        <!-- TABS NAV-->
        <ul class="tabs-nav-list">
          <li class="tabs-nav-item active" onclick="openMark(event,'mark1')">Типы данных</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark2')">Строки</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark3')">Числа</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark4')">Boolean</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark5')">Null, undefined</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark6')">Словарик</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark7')">Переменные</li>
          <li class="tabs-nav-item" onclick="openMark(event,'mark8')">Тестовые</li>
        </ul>
        <!-- END NAV -->
      </div>
      <div class="info-right">
        <div id="extra-menu" class="links-themes-list"></div>
        <ul class="tabs-content-list info-right-content">
          <li id="mark1" class="tabs-content-item active">
            <!-- 1 -->
            <div class="sub-title">Main</div>
            <div class="title">Типы данных</div>

            <fieldset>
              <legend>1. Преображение типов данных</legend>
              <pre>
                <code>
                  <b>Str -> Num</b>
                  parseInt(somestring) to -> number
                  
                  <b>Num -> Str</b>
                  String(num) -> преобразовать в строку
                  
                  <b>Arr -> Str</b>
                  arr.join(', ') - соеденить массив в строку и поставить кому между ел. 
                  arr.join(str) берет массив и склеивает его в строку, используя str как разделитель
                  
                  <b>Str -> Arr</b>
                  [ num(str) ] -> преобразовать в массив
                  split(s) - который позволяет превратить строку в массив,разбив ее по разделителю s 

                  <b>isNaN(num)</b> -- проверяет является ли строка числом
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>2. Poster</legend>
              <pre>
                <code>
                   Здесь могла бы быть ваша реклама!
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>3. Остаток от деления %</legend>
              <blockquote>
                Взятие остатка % Оператор взятия остатка % интересен тем, что его результат a % b – это остаток от деления a на b.
              </blockquote>
              <pre>
                <code>
                   Например: 
                   alert( 5 % 2 ); // 1
                   alert( 8 % 3 ); // 2
                   alert( 6 % 3 ); // 0
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>4. Операторы сравнения</legend>
              <pre>
                <code>
                   null == undefined, //true 
                   "\t\r\n" == 0, //true 
                   0 == "", //true 
                   false == "false" //false
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>5. Логические операторы || && </legend>
              <blockquote>
                Одно и тоже выражение может записываться по-разному в зависимости от сценария.
                В позитивном сценарии диапазон попадает на и &&.
                В негативном он расходится или (x < 0) или (x > 150)
              </blockquote>
              <pre>
                <code>
                  <b>Негативный сценарий</b>
                  setAge(age) { 
                    if (age < 0 || age > 150) { 
                      alert('this is fake age') 
                    } else { 
                      this._age = age;
                    } 
                  }

                  <b>Позитивный сценарий</b>
                  setAge(age) { 
                    if (age > 0 && age < 150) { 
                      this._age = age; 
                    } else { 
                      alert('this is fake age') 
                    } 
                  }

                  <b></b>
                  if (1 || 0) { // сработает как if( true || false ) alert( 'верно' ); 
                  }
                </code>
              </pre>
              <blockquote>
                || запинается на «правде», 
                && запинается на «лжи».
              </blockquote>
            </fieldset>
            <!-- end 1 -->
          </li>
          <li id="mark2" class="tabs-content-item">
            <!-- 2 -->
            <div class="sub-title">Main</div>
            <div class="title">Строки/ String</div>

            <fieldset>
              <legend>1. Методы строк</legend>
              <pre>
                <code>
                  <b>Преобразовать</b>
                  String.prototype.toString() -- Преобразует в строку
                  String.prototype.split() -- разбивает строку на массив по символу
                  String.prototype.quote() -- Оборачивает строку в двойные кавычки (""")
                  
                  <b>Трансформировать</b>
                  String.prototype.concat(str) -- Объединяет 2 строки в одну
                  String.prototype.repeat(count) -- Дублирует строку

                  <b>Заменить участок</b>
                  String.prototype.replace() -- Заменяет совпавшую строку на новую
                  String.prototype.slice() -- Извлекает часть строки и возвращает новую строку  

                  <b>Обрезать</b>
                  String.prototype.substring() -- Возвращает символы в строке между двумя индексами

                  <b>Вернуть символ</b>
                  String.prototype.indexOf() -- Возвращает индекс символа в строке (indexOf применяется и к Array.prototype.indexOf)
                  String.prototype.lastIndexOf() -- Возвращает индекс последнего вхождения
                  String.prototype.charAt() -- Возвращает символ по указанному индексу
                  String.prototype.substr() -- Возвращает указанное количество символов в строке, начинающихся с указанной позиции
                  
                  <b>Найти</b>
                  String.prototype.search() -- Выполняет поиск со строкой
                  
                  <b>Убрать пробелы, Регистр</b>
                  String.prototype.trim() -- Обрезает пробелы в начале и в конце строки 
                  String.prototype.trimLeft() -- Обрезает пробелы с левой стороны строки 
                  String.prototype.trimRight() -- Обрезает пробелы с правой стороны

                  String.prototype.toLowerCase() -- Переводит в нижний регистр
                  String.prototype.toUpperCase() -- Переводит в верхний регистр
                  
                  <b>Инфо</b>
                  String.prototype.startsWith() -- Определяет, начинается ли строка символами другой строки
                  String.prototype.includes() -- Определяет, находится ли строка внутри другой строки 
                  String.prototype.constructor -- Определяет функцию, создающую прототип этого объекта. 
                  String.prototype.endsWith() -- Определяет, заканчивается ли строка символами другой строки 
                  String.prototype.match() -- Используется для сопоставления строке регулярного выражения
                </code>
              </pre>
            </fieldset>
            <!-- end 2 -->
          </li>
          <li id="mark3" class="tabs-content-item">
            <!-- 3 -->
            <div class="sub-title">Main</div>
            <div class="title">Числа</div>
            <fieldset>
              <legend>1. Методы чисел</legend>
              <h3>Методы Math</h3>
              <pre>
                <code>
                  <b>Math.round(x)</b> -- округляет число(стандартно)
                  <b>Math.ceil(x)</b> -- округляет до большего целого числа
                  <b>Math.floor(x)</b> -- округляет в меньшую сторону
                  <b>Math.pow(x, y)</b> -- возвращает степень
                  <b>Math.random()</b> -- случайное число в диапазоне 0-1
                  <b>Math.max([x[, y[, …]]])</b> -- Возвращает найбольшее число из своих аргументов
                  <b>Math.min([x[, y[, …]]])</b> -- Возвращает наименьшее число из своих аргументов
                  <b>Math.sqrt(x)</b> -- Возвращает квадратный корень числа
                </code>
              </pre>
            </fieldset>
            <!-- end 3 -->
          </li>
          <li id="mark4" class="tabs-content-item">
            <!-- 4 -->
            <div class="sub-title">Main</div>
            <div class="title">Boolean: true/false</div>
            <fieldset>
              <legend>1. Флаги - Flags</legend>
              <p>
                Флаги полезны когда нужно вернуть только булеан
              </p>
              <pre class="code">
                <code>
                  <b>result: true or false</b>        
                  let mas = ['a','b','c','d','e','c']; 
                  function hasElem(mass, num) { 
                    for (let i=0; i < mass.length; i++) { 
                      if (num==m ass[i]) { 
                        return true; 
                      } 
                    } 
                    return false; 
                  }; 
                  alert(hasElem(mas, 'c'));
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>2. Функция как условие true false</legend>
              <p>
                Мы перезаписываем функцию в зависимости от условия
              </p>
              <pre class="code">
                <code>    
                  var bool = true; 
                  if (bool) { 
                    var func = function () { 
                      alert('!'); 
                    } 
                  } else { 
                    var func = function () { 
                      alert('!!'); 
                    } 
                  };

                  func();
                </code>
              </pre>
            </fieldset>
            <!-- end 4 -->
          </li>
          <li id="mark5" class="tabs-content-item">
            <!-- 5 -->
            <div class="sub-title">Main</div>
            <div class="title">Null, Undefined</div>
            <fieldset>
              <legend>1. </legend>
              <pre class="code">
                <code>
                </code>
              </pre>
            </fieldset>
            <!-- end 5 -->
          </li>
          <li id="mark6" class="tabs-content-item">
            <!-- 6 -->
            <div class="sub-title">Main</div>
            <div class="title">Словарик</div>
            <fieldset>
              <legend>1. Термины</legend>
              <pre>
                <code>
                  <ol>
                    <li>
                        <b>LexicalEnvironment</b> - все переменные внутри функции
                    </li>
                    <li>
                      <b>Scope</b> - создается вместе с функциями и предоставляет им доступ к переменным       
                    </li>
                    <li>
                      <b>Рекурсия</b> - это когда в выполнение функции заложено выполнять саму себя n к-во раз как в примере со степенью числа.
                    </li>
                    <li>
                      <b>Этерация</b> - повторение цикла Для нового вызова создаётся свой контекст выполнения, и управление переходит в него, а когда он завершён – старый контекст достаётся из стека и выполнение внешней функции возобновляется.
                    </li>
                    <li>
                      <b>Контекст</b> - это служебная информация, которая соответствует текущему запуску функции. Она включает в себя локальные переменные
                      функции и конкретное место в коде, на котором находится интерпретатор.
                    </li>
                    <li>
                      <b>Стэк</b> - Порядок вызова функций где компьютер запоминает контекст, называется стеком. Будущие и прошедшие операции в очереди.
                    </li>
                    <li>
                      <b>Литералы</b> test=new Array()
                    </li>
                    <li>     
                      <b>let</b> - let, которое работает как var, но создает переменные, локальные для любого данного блока, а не только для функции. Блок имеется ввиду все что стоит в фигурных скобках - {}
                    </li>
                    <li>
                      Function-<b>Declaration</b> : function func() { //... }); 
                      Function-<b>Expression</b> : func = function() { //... });
                    </li>
                    <li>
                      <b>Hoisting</b> - процесс доступа компилятора к переменным
                    </li>
                    <li>
                      <b>Инкапсуляция </b> - есть ни что иное, как реализация приватности.
                    </li>
                    <li>
                      <b>Наследование </b> - вы, буквально, говорите: “У меня есть один конструктор/класс и другой конструктор/класс, который точно такой же, как и первый, кроме вот этого и вот этого”
                      <blockquote>
                        Чаще всего наследование в JavaScript реализуется с помощью функции Object.create(),позволяющий создать новый объект с заданным прототипом.
                      </blockquote>
                    </li>
                    <li>
                      <b>Статические переменные</b> - переменные, которые сохраняют промежуточные значения между вызовами. 
                      <br>Прим. func 1.15 counter но не через callback, а через вложеную функцию, которая считает и перезапысывает внешнюю переменную, которую и возвращает функция. 
                    </li>
                  </ol>
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>2. Рекурсия</legend>
              <h5><b>Peкурсия</b> - это когда в выполнение функции заложено выполнять саму себя n к-во раз как в примере со степенью числа.</h5>
              <blockquote>
                Говорят, что «функция pow рекурсивно вызывает сама себя» до n == 1. Значение, на котором рекурсия заканчивается, называют
                базисом рекурсии. pow(x, n) = x * pow(x, n - 1) x - число; n - степень
                <ol>Например, вычислим pow(2, 4), последовательно переходя к более простой задаче:
                  <li>pow(2, 4) = 2 * pow(2, 4)</li>
                  <li>pow(2, 3) = 2 * pow(2, 3)</li>
                  <li>pow(2, 3) = 2 * pow(2, 2)</li>
                  <li>pow(2, 3) = 2 * pow(2, 1)</li>
                </ol>
                При выполнении pow(2, 1), в отличие от предыдущих запусков, выражение n != 1 будет равно false, поэтому сработает else гле
                х == самому числу
              </blockquote>
              <pre class="code">
                <code>
                  function pow(x, n) { 
                    if (n != 1) { 
                      // пока n != 1, сводить вычисление pow(x,n) к pow(x,n-1) 
                      return x * pow(x, n - 1); 
                    } else { 
                      return x; 
                    } 
                  } 
                  
                  alert( pow(2, 3) ); // 8

                  <b>Вариант с циклом намного экономнее</b>
                  let quoxx = function(x,y) { 
                    let foo = x; 
                    for (; y >= 1; y--) { 
                      foo *= x; 
                    } 
                    return foo; 
                  } 
                  quoxx(2, 4)
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>3. LexicalEnvironment</legend>
              <h5><b>LexicalEnvironment</b> - все переменные внутри функции - это свойства специального внутреннего объекта LexicalEnvironment, который создается при ее запуске.</h5>
              <blockquote>
                До выполнения первой строчки её кода, на стадии инициализации, интерпретатор создает пустой объект LexicalEnvironment и заполняет
                его. Во время выполнения происходит присвоение локальной переменной phrase, то есть, другими словами, присвоение свойству
                LexicalEnvironment.phrase нового значения:
              </blockquote>
              <pre class="code">
                <code>
                  function sayHi(name) { 
                    // LexicalEnvironment = { name: 'Вася', phrase: undefined } 
                    var phrase = "Привет, " + name; 
                    
                    // LexicalEnvironment = { name: 'Вася', phrase: 'Привет, Вася' } 
                    alert( phrase ); 
                  } 
                  
                  sayHi('Вася');
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>4. Стек</legend>
                <h5><b>Стэк</b> - Порядок вызова функций где компьютер запоминает контекст, называется стеком. Будущие и прошедшие итерации в очереди.</h5>
                <ul>
                  n--
                  <li>Контекст: { x: 2, n: 3, строка 1 } // Контекст</li>
                  <li>Контекст: { x: 2, n: 2, строка 2 } // Стек </li>
                  <li>Контекст: { x: 2, n: 1, строка 3 } // Стек </li>
                </ul>
                <blockquote>
                  pow(2, 1) Опять вложенный вызов в строке 3, на этот раз – с аргументами x=2, n=1. Создаётся новый текущий контекст, предыдущий
                  добавляется в стек (в стеке уже два старых контекста) Kаждый раз при вызове функции, текущий контекст помещается наверх
                  стека. Тогда функция возвращается, она забирает верхний контекст из стека и использует его для продолжения работы.
                </blockquote>
            </fieldset>
            <!-- end 6 -->
          </li>
          <li id="mark7" class="tabs-content-item">
            <!-- 7 -->
            <div class="sub-title">Main</div>
            <div class="title">Метапеременные</div>
            <fieldset>
              <legend>Слова получающие значение в зависимости от контекста</legend>
              <pre>
                <code>
                  <h4>RFC - журнал  <a href="https://tools.ietf.org/html/rfc3092">ссылка на статью</a>
                  </h4>
                    <b>foo</b>(bar) - первая. army slang FUBAR((`Fucked Up Beyond All Repair'))
                    <b>bar</b> - вторая 
                    <b>baz</b> - третья 
                    <b>bat, qux, quux</b> — четвертая
                     
                  <h5>First on the standard list of metasyntactic variables</h5>
                    <b>corge</b>
                    <b>grault</b>
                    <b>garply</b>
                    <b>waldo</b>
                    <b>thud</b>

                  <h4>Whoop! Восклицание</h4> 
                   <b>Many smoke but foo men chew</b>
                   <b>SILENCE IS FOO!</b> - Whoop!(Восклицание)
                   <b>Many smoke but foo men chew</b>

                  <h4>Funny hystorical</h4>
                    <b>spam и eggs</b> — канонические метапеременные, используемые в языке программирования Python.
                    <b>xyzzy и plugh</b> — волшебные слова в старой текстовой игре ADVENT.
                  
                  <h4>Иголка в стоге сена - haystack(needle)</h4> 
                    <b>needle (иголка) и haystack (стог сена)</b> могут использоваться в примерах, объясняющих синтаксис команд или функций поиска; благодаря идиоме «искать иголку в стоге сена», становится понятно, что в чём ищется.
                    <b>qwe, asd, zxc</b> — набор символов для ввода информации в текстовые поля для быстрого заполнения
                  
                  <h4>переменные действия</h4>
                    <b>mv</b> - переименовать ск move
                    <b>rm</b> - удалить remove
                    <b>view</b> - посмотреть
                  
                  <h4>переменные элементов</h4>
                    <b>source</b> - источник
                    <b>target</b> - цель
                    <b>ls</b> - список list
                  
                  <h4>пользователь - somebody</h4>
                    <b>DaffyDoc</b> - User. Warner Bros later - daffyduck
                    <b>fred</b> 
                    <b>jRand</b>
                    <b>JohnDoe</b> - неизвестный
                </code>
              </pre>
            </fieldset>
            <!-- end 7 -->
          </li>
          <li id="mark8" class="tabs-content-item">
            <!-- 8 -->
            <div class="sub-title">Main</div>
            <div class="title">Тестовые</div>
            <fieldset>
              <legend>Из центра наружу</legend>
              <blockquote>Очередность вызова переменных</blockquote>
              <pre>
                <code>
                  var foo = 6; 

                  function test() { 
                    var foo = 7; 
                    function more() { 
                      var foo = 8; 
                      console.log(foo); // 1 
                    } 
                    more(); 
                    console.log(foo); // 2 
                  }; 
                  test(); ​
                  console.log(foo);​ // 3
                  </code>
                </pre>
            </fieldset>
            <fieldset>
              <legend>2. true / false</legend>
              <blockquote>
                Здесь колбеком принимается массив аргументов. В нем же применяется reverse. 
                А при вызове, где мы передаем аргументы мы приравниваем элементы массива аргументов - с конца.
              </blockquote>
              <pre class="code">
                <code>
                  function largest() { 
                    return toArray(arguments).sort(function (a, b) { 
                      return b - a; 
                    }); 
                  } 

                  function toArray(array) { 
                    return Array().slice.call(array); 
                  } 
                    
                  console.log(largest(1, 1, 2, 3)[0] == 3); //true
                  console.log(largest(3, 1, 2, 3, 4, 5)[1] == 4); //true
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>3. Конструктор</legend>
              <blockquote>Почему move не находит, а с name все ок?</blockquote>
              <pre class="code">
                <code>
                  let Animal = function() { 
                    this.name = name; 
                    // this.move = move; -- move is not defined
                  }; 
                  
                  let gorilla = new Animal(); 
                  
                  gorilla.name = 'gorilla'; 
                  gorilla.move = 'jump';

                  console.log(gorilla);
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>4. "Всплытие переменной"</legend>
              <blockquote>Перезапись глобальной переменной</blockquote>
              <pre class="code">
                <code>
                  var foo = 0;
                  var bar = function () { 
                    var baz = function () { 
                      foo = 31337; 
                    }; 
                    baz(); 
                    console.log(foo); 
                  }; 
                  
                  bar(); //31337
                </code>
              </pre>
            </fieldset>
            <fieldset>
              <legend>5. </legend>
              <blockquote></blockquote>
              <pre class="code">
                <code>
                  
                </code>
              </pre>
            </fieldset>
            <!-- end 8 -->
          </li>
        </ul>
      </div>
    </div>
  </div>

  <script src="../../js/main/hilight.js"></script>
  <script src="../../js/main/dynamic.js"></script>
  <script src="../../js/main/main.js"></script>

</body>

</html>