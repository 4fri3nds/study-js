<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <link rel="stylesheet" href="../../css/style.css">
</head>

<body>

  <a href="index.html">home</a>
  <blockquote>
    <h3>practice</h3>
    <ol>
      <li>
        стрелочная функция 
      </li>
      <li>
        метод перебора массива forEach
      </li>
      <li>
        стрелочная функция для forEach
      </li>
    </ol>
  </blockquote>

  <div class="container">
    <fieldset>
      <!-- \\__====|_ ПРАКТИКА _|===// -->
      <legend>Напоминалка Code</legend>
      <ol>
        <li>
          Преображение типов данных
          <pre>
            parseInt(somestring) to -> number
            String(num) -> преобразовать в строку
            [ num(str) ] -> преобразовать в массив
          </pre>
        </li>
        <li>
          <p>Прикольные записи</p>
          <pre>
            if(y === undefined) y = 5;
            (y === undefined) ? (do...) : (else do ...)
            mass == [1,2,3]; ...mass // 1 2 3; 
            func(...mass) == func(1,2,3) //true

          </pre>
        </li>
        <li>
          ДОБАВЛЕНИЕ И УДАЛЕНИЕ УЗЛОВ
          <hr>
          <h3>
            Создать эл. и вставить
          </h3>
          <pre>
            let divEl = document.createElement('div');
            divEl.className = "includer"; //divEl.classList = "cl-1 cl-2..."
            divEl.innerHTML = str;
            location.appendChild(divEl);
          </pre>
          <hr>
          <h3>
            Clone скопировать эл. и вставить
          </h3>
          <pre>
            var div2 = div.cloneNode(true); // копию можно подправить 
            div2.querySelector('strong').innerHTML = 'Супер!'; 
            // вставим её после текущего сообщения 
            div.parentNode.insertBefore(div2, div.nextSibling);
          </pre>
          <hr>
          <h3>insertBefore</h3>
          <p>Вставить до и после конкретного элемента</p>
          <pre>
            // this.parentElement.insertBefore(el, this); мой вариант

            var insertedElement = parentElement.insertBefore(newElement, referenceElement);
          </pre>
          <ul style="list-style-type: disc;">
            <li>insertedElement Вставленный элемент.</li>
            <li>parentElement Родитель для нового элемента.</li>
            <li>newElement Элемент для вставки.</li>
            <li>referenceElement Элемент, перед которым будет вставлен newElement.</li>
          </ul>
        </li>
        <hr>
        <li>
          задать интервал выполнения прекратить интервал выполнения
          <pre>
            let interval = setInterval(countdown, 500)
            function stop() { window.clearInterval(interval) } 
          </pre>
        </li>
        <li>
          <h3>Методы перебора</h3>
          <p>Метод WHILE</p>
          <pre>
            while(true) { ... }
          </pre>
          <hr>
          <h3>Методы перебора массивов</h3>
          <p>forEach</p>
          <b>Этой функции он передаёт три параметра callback(item, i, arr) </b>
          <ul>
            <li>item – очередной элемент массива. </li>
            <li>i – его номер. </li>
            <li>arr – массив, который перебирается.</li>
          </ul>
          <pre>
            var arr = ["Яблоко", "Апельсин", "Груша"]; 
            arr.forEach(function(item, i, arr) { 
              alert( i + ": " + item + " (массив:" + arr + ")" ); });
          </pre>
          <hr>
          <p>
            Filter -- Метод filter() создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.
          </p>
          Можно использовать, чтобы получить разницу чисел одного массива
          <pre>
            let difference = arr1.filter(x => arr2.indexOf(x) == -1);

            аналог: 
            let difference = arr1.filter(
              function(x) { 
                return arr2.indexOf(x) == -1; 
            });
          </pre> Чтобы получить разницу обоих массивов
          <pre>
            let difference = arr1 
              .filter(x => arr2.indexOf(x) == -1) 
              .concat(arr2.filter(x => arr1.indexOf(x) == -1));
          </pre>
          <hr>
          <p>Map - для каждого элемента массива делает тоже самое</p>
          <b>
            Он создаёт новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr
          </b>
          <pre>
            var names = ['HTML', 'CSS', 'JavaScript']; 
            
            var nameLengths = names.map(function(name) { 
              return name.length; 
            }); // получили массив с длинами 
            
            alert( nameLengths ); // 4,3,10
          </pre>
          <hr>
          <p>every/some</p>
          <b>
            Эти методы используются для проверки массива.
          </b>
          <ul>
            <li>
              every возвращает true if callback == true для каждого элемента arr.
            </li>
            <li>
              some возвращает true if callback == true для какого-нибудь элемента arr.
            </li>
          </ul>
          <pre>
            var arr = [1, -1, 2, -2, 3]; 
            
            function isPositive(number) { 
              return number > 0; 
            };
            
            alert( arr.every(isPositive) ); // false, не все положительные
            alert( arr.some(isPositive) ); // true, есть хоть одно положительное
          </pre>
          <hr>
          <p>
            <b>Случайное число из массива</b>
          </p>
          <pre>
            var arr = ["Яблоко", "Апельсин", "Груша", "Лимон"]; 
            
            var rand = Math.floor(Math.random() * arr.length); 
            
            alert( arr[rand] );
          </pre>
        </li>
        <li>
          Добавить и удалить классы
          <pre>
            document.body.classList.add('thisClass'); 
            document.body.classList.remove('thatClass');
            document.body.classList.toggle('anotherClass'); 

            body.classList.contains('thatClass') -- проверка на наличие
          </pre>
        </li>
        <li>
          Управление DOM елементами
          <pre>
            - getElementById id - везде 
            - getElementsByName name - везде   
            - getElementsByTagName - тег или '*' - получить всех потомков, 
            - getElementsByClassName
            - querySelector 
            - querySelectorAll - ('ul > li:last-child')

            - elem.matches(css) ничего не ищет, а проверяет, удовлетворяет ли elem селектору css. Он возвращает true либо false.
            
            elem.closest(css)
            parentNode возвращает родитель элемента.
            parentElement
            childNodes()
            children - только дочерние узлы-элементы, то есть соответствующие тегам
            firstChild, lastChild -  – соответственно, первый и последний дети-элементы
            previousElementSibling, nextElementSibling – соседи-элементы
          </pre>
        </li>
        <li>
          <p>МАССИВЫ - Array методы</p>
          <pre>
            arr.push(item) -- добавляет новый элемент в конец! массива
            arr.pop() -- Удаляет последний элемент из массива и возвращает его
            arr.shift() -- Удаляет из массива первый элемент
            arr.unshift('apple') -- Добавляет в начало массива элемент
            <i>Методы push и unshift могут добавлять сразу по несколько элементов:</i>

            arr.join(', ') - соеденить массив --> строку и поставить кому между ел.
            arr.splice(1, 1); - начиная с позиции 1, удалить 1 элемент
            split(s) - который позволяет превратить строку в массив, разбив ее по разделителю s
            arr.join(str) делает в точности противоположное split. Он берет массив и склеивает его в строку, используя str как разделитель 
            slice(begin, end) копирует участок массива от begin до end, не включая end. Если не указать end – копирование будет до конца массива
            arr.sort(fn) нужно передать функцию fn от двух элементов, которая умеет сравнивать их.
            arr.reverse() меняет порядок элементов в массиве на обратный.
            arr.concat(arr2) - обьеденяет массивы
            arr.indexOf(searchElement[, fromIndex]) - возвращает номер элемента searchElement в массиве arr или -1, если его нет.
            arr.lastIndexOf(searchElement[, fromIndex])» ищет справа-налево: с конца массива или с номера fromIndex, если он указан
            Object.keys(obj) -- for...in для массивов
          </pre>
        </li>
        <li>
          <p>
            OBJECT - обьекты
          </p>
          <h3>методы обьектов</h3>
          <pre>
            Object.keys(obj) -- так можно обратится к значениям обьекта
            obj[arr[i]] = true -- уникальным элементам массива мы в обьекте даем значение true. Tак они больше не повторяются
          </pre>
          <h3>перебор обьектов</h3>
          <p>
            for..in -- При этом for..in последовательно переберёт свойства объекта obj, имя каждого свойства будет записано в key и вызвано
            тело цикла.
          </p>
          <pre>
            for (var key in menu) { // ... }
          </pre>
        </li>
        <li>
          <p>СТРОКИ - String</p>
          <pre>
            arr = value.split(',') - разбивает строку --> массив по символу
            slice(start, end) 
            substring(start, end) 
            substr(start, length)
            charAt -- узнаем какой именно символ(на этой позиции)
          </pre>
        </li>

        <li>
          addEventListener события
          <pre>
            checkbox.addEventListener('change') -- вешается на checkbox'ы
            checkbox.addEventListener('checked') -- вешается на checkbox'ы
            .addEventListener('mouseup', func) -- срабатывает при отжатии мышки
          </pre>
        </li>
        <li>
          Добавлять css через js
          <pre>
            elem.style.display = 'none';
            css - user-select: none -- отменяет выделение          
          </pre>
        </li>
        <li>
          <p>АТТРИБУТЫ</p>
          <pre>
            elem.getAttribute() -- получить доступ к атрибуту 
            elem.setAttribute() -- дать эл. аттр. 
            elem.hasAttribute() -- прoверить на наличие аттрибута 
            elem.removeAttribute(name) -- удаляет аттр.

            input.setAttribute('disabled', 'disabled'); -- зделать input неактывным.
          </pre>
        </li>
        <li>
          Добавить и удалить класс
          <pre>
             classList.remove('page'); // удалить класс 
             classList.add('post'); // добавить класс
          </pre>
        </li>
        <li>
          Методы строк String.prototype.slice() Извлекает часть строки и возвращает новую строку. String.prototype.split() Разбивает
          объект String на массив строк, разделёных указанной строкой на подстроки.
        </li>
        <li>
          Метод call позволяет вызвать функцию из другого обьекта.
          <pre>
             test.function_property.call(test2, 'user_1');
          </pre>
        </li>
        <li>
          Возвращает минимальное и максимальное значение массива
          <pre>
             Math.min.apply(null, [3,5,2]) //2
             Math.max.apply(null, [3,5,2]) //5
          </pre>
        </li>
        <li>
          Удалить элемент из массива
          <pre>
            <p>result: ['bar', 'baz']</p>
             var a = ['foo', 'bar', 'baz']; 
             
             a.splice(0,1) -- удаляет один элемент начиная с позиции 0
          </pre>
        </li>
        <li>
          Сортировка массива
          <pre>
             function compareNumbers(a, b) { 
               return a - b; 
             } -- Функция для сортировки чисел, используется с методом sort
             
             arr.sort(compareNumbers) -- метод .Sort()
          </pre>
        </li>
        <li>
          Передача и использование this в универсальной функции
          <pre>
            func.call(elem, x1, x2)
            func.apply(elem, [x1, x2]) 
            func.bind(elem)
          </pre>
        </li>
        <li>
          Вот так засунуть выполнение функции в true - false
          <pre>
            var bool = true;

            if (bool) { var func = function () { alert('!'); } 
            } else { var func = function () { alert('!!'); } } 
            
            func();
          </pre>
        </li>
        <li>
          <h3>
            <u>Методы math</u>
          </h3>
          <ul>
            <li>
              <b>Math.round(x)</b>
              - округляет число(по нормальному)
            </li>
            <li>
              <b>Math.ceil(x)</b>
              округляет до большего целого числа
            </li>
            <li>
              <b>Math.floor(x)</b>
              - округляет в меньшую сторону
            </li>
            <li>
              <b>Math.pow(x, y)</b>
              - возвращает степень
            </li>
            <li>
              <b>Math.random()</b>
              - случайное число в диапазоне 0-1
            </li>
            <li>
              <b>Math.max([x[, y[, …]]])
              </b>
              Возвращает найбольшее число из своих аргументов
            </li>
            <li>
              <b>Math.min([x[, y[, …]]])</b>
              Возвращает наименьшее число из своих аргументов
            </li>
            <li>
              <b>Math.sqrt(x)</b>
              Возвращает квадратный корень числа
            </li>
          </ul>
        </li>
        <li>
          <h3>ES6 - Метод filter()</h3>
          Метод filter() создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.
          <pre>
            const words = ["spray", "limit", "elite", "exuberant", "destruction", "present", "happy"]; 
            let longWords = words.filter(word => word.length > 6); 
            // Отфильтрованный массив longWords ["exuberant", "destruction", "present"]
          </pre>
        </li>
        <li>
          <p>OBJECT - ОБЬЕКТЫ – это ассоциативные массивы</p>
          <h3>Проверить на наличие свойства</h3>
          <p>проверить существование свойства – получив его и сравнив с undefined:</p>
          <pre>
            var person = { name: "Василий" }; 
            alert( person.lalala === undefined ); // true, свойства нет 
            alert( person.name === undefined); // false, свойство есть.
          </pre>
          <p>проверить существование свойства – оператором indefined:</p>
          <pre>
            var obj = {}; 
            obj.test = undefined; 
            alert( "test" in obj ); // true 
            alert( "blabla" in obj ); // false
          </pre>
          <h3>Хранение данных</h3>
          <pre>
            var user = { 
              name: "Таня", 
              age: 25, 
              size: { 
                top: 90, 
                middle: 60, 
                bottom: 90 
              } 
            } 
            alert(user.name) // "Таня" 
            alert(user.size.top)// 90
          </pre>
          <h3>Завести или удалить параметр</h3>
          <pre>
            person[key], person.key // обратится
            person[key] = 'Джаз' // присвоить переменную
            
            delete person.age // удалить св age из обьекта person
          </pre>
          <i>Доступ через точку используется, если мы на этапе написания программы уже знаем название свойства. А если оно будет
            определено по ходу выполнения, например, введено посетителем и записано в переменную, то единственный выбор –
            квадратные скобки.</i>
          <h3>Перебор обьектов</h3>
          <pre>
            obj = {name: 'Вася', age: 32};
            for (key in obj) { /* ... делать что-то с obj[key] ... */ }
          </pre>
          <p>более короткий перебор -- !! стоит попробовать</p>
          <pre>Object.keys(menu).length</pre>
        </li>
        <li>
          <pre>
            class Elem { 
              constructor(selector) { 
                this.menu = document.querySelector(selector); 
              }; 
              
              html(text) { 
                this.menu.innerHTML = text; 
              } 
            };
             
            let menu = new Elem('#menu'); 
            menu.html('hello');
          </pre>
        </li>
      </ol>
    </fieldset>
    <!-- \\__====|_ ТЕОРИЯ _|===// -->
    <fieldset>
      <legend>Теория Напоминалка</legend>
      <ol>
        <li>
          Нужно не забывать что повторяющаяся функция переписывает переменные на начальные, если они находятся в середине.
        </li>
        <li>
          Также верхнее this можно положить опять таки в переменную, которую передать в функции пониже.
          <pre>let that = this.value;</pre>
        </li>
        <li>
          очень удобно, когда то что мы должны зделать с элементом лежит в самом элементе в VALUE = "..."
          <pre>
            input type="checkbox" value="font-weight:bold;">сделать жирным
          </pre>
        </li>
        <li>
          <h6>Литералы</h6>
          Не стоит путать использование примитивных значений с использованием литералов — например :
          <pre>
             «test=new Array()» или как «test=[]»
           </pre>
        </li>
        <li>
          Употребление this в функции. Чтобы передать this - нужно передать это в параметр. Откуда ее вызываем.
          <pre>
            triggerClassActive(this, sumCellsArr, x);    
          </pre>
        </li>
        <li>
          LexicalEnvironment - ¬се переменные внутри функции Ц это свойства специального внутреннего объекта LexicalEnvironment, который
          создаЄтс€ при еЄ запуске. «амыкани€, функции изнутри
        </li>
        <li>
          let - let, которое работает как var, но создаЄт переменные, локальные дл€ любого данного блока, а не только дл€ функции.
          Ѕлок имеетс€ ввиду все что стоит в фигурных скобках - {}
        </li>
        <li>
          ѕор€док вызова функций ћесто, где компьютер запоминает контекст, называетс€ стеком. function greet(who) { console.log("ѕривет,
          " + who); //first } greet("—емЄн"); console.log("ѕокеда"); //second  аждый раз при вызове функции, текущий контекст
          помещаетс€ наверх стека.  огда функци€ возвращаетс€, она забирает верхний контекст из стека и использует его дл€
          продолжени€ работы.
        </li>
        <li>
          ѕовторение цикла по-научному называетс€ Ђитераци€ї
        </li>
        <li>
          <pre>
            //Function Declaration: function func() { alert('!'); }); 
            
            //Function Expression: var func = function() { alert('!'); });
          </pre>
        </li>
        <li>
          Использование 'use strict' может вызвать кучу ошибок.
          <pre>
            "use strict"; 
            var bool = true; 
            if (bool) { 
              function func() { 
                alert('!'); } 
              } 
            func(); //выдаст ошибку - тут функция не видна!
          </pre>
        </li>
        <li>
          В js функции не копируются, а ссылаются друг на друга.
          <pre>
            function func() { alert('!'); }); 
            var test = func; //И test и func указывают на одну и ту же функцию
          </pre>
        </li>
        <li>
          Можно передать функцию параметром
          <pre>
             var get1 = function() { return 1; } var get2 = function() { return 2; }
             
             function go(func1, func2) { 
               alert(func1() + func2()); 
              } 
              
              go(get1, get2); //выведет 3
          </pre>
        </li>
        <li>
          Так можно использовать анонимную функцию
          <pre>
             function go(func) { 
               func(); 
              }); 
              go(function() { 
                alert('!'); 
              });
          </pre>
        </li>
        <li>
          функция возвращает внутреннюю функцию. Вызвать внутреннюю можно func()()
          <pre>
              function func() { 
                return function() { 
                  return '!'; 
                }; 
              } 
              
              alert( func()() ); //увидим '!'
          </pre>
        </li>
        <li></li>
        <li></li>
      </ol>
    </fieldset>
    <fieldset>
      <legend>стрелочные функции</legend>
      <p>Перевод input в верхний регистр</p>
      <pre>
        <b>old</b>
         function toUpper(str) {return str.toUpperCase()}
      </pre>
      <pre>
        <b>new</b>
         let toUpper = str => str.toUpperCase();
      </pre>
      <p>this в стрелочных функциях не существует поэтому он ищет контекст уровнем выше</p>
      <pre>
        $('.current-time').each(function () { 
          setInterval(() => $(this).text(Date.now()), 1000); 
        });
      </pre>
    </fieldset>

    <fieldset>
      <legend>blur</legend>
      <p>Передает параметры в консоль</p>
      <input type="text" id="task">
      <pre>
        <b>old</b>
         let task = document.getElementById('task'); 
         function value(val) { 
           console.log(val.value); // принимаем value с другой функции
        и здесь мы можем делать с ним что угодно 
        } 
        task.onblur = function someFunc() { 
          value(this) //передаем значение this при blure.
          Получается мы здесь вызываем другую функцию дав ей в параметр то что нужно этой функции 
        }
      </pre>
    </fieldset>

    <fieldset>
      <legend>arguments - псевдомассив аргументов в функциях</legend>
      <p>arguments[0], arguments[1]</p>
      <pre>
        <b>Когда мы не предаем аргуметы изначально</b>
        function sayHi() { 
          for (var i = 0; i < arguments.length; i++) { 
            alert( "Привет, " + arguments[i] ); 
          } 
        } 
        sayHi( "Винни", "Пятачок"); // 'Привет, Винни', 'Привет, Пятачок'
      </pre>
      <br>
      <pre>
        <b>мы можем создать массив из аргументов</b>
        var args = []; 
        for (var i = 0; i < arguments.length; i++) { 
          args[i] = arguments[i]; 
        };
      </pre>
    </fieldset>

    <fieldset>
      <legend>forEach</legend>
      <p>
        let someArr = ['значение1', 'значение2', 'значение3'];
      </p>
      <pre>
        <b id="wrap-for-each1">result</b>
         someArr.forEach(function callback(currentValue, index, array) { 
           div('this is value : ' + currentValue); 
           div('this is index: ' + index); 
           div('this is array : ' + array); 
          });
      </pre>
      <span>OR</span>
      <pre>
        arr.forEach( item => console.log(item) );  
      </pre>
      <button id="but">click</button>
    </fieldset>

    <fieldset>
      <legend>forEach стрелочная функция</legend>
      <p>
        let someArr = ['значение1', 'значение2', 'значение3']; выводит значения массива в дивы
      </p>
      <pre>
        <b id="wrap-for-each2">result</b>        
         someArr.forEach(callback = (currentValue, index, array) => (console.log(currentValue)));
      </pre>
      <button id="but2">click</button>
    </fieldset>

    <fieldset>
      <legend>setInterval ^ setTimeout</legend>
      <p>
        setInterval - задает интервал повторного выполнения функции, setTimeout - прекращает это. Третий пример с использованием
        рекурсивного setTimeout - true way.
      </p>
      <pre>
        <b id="wrap-set-interval">result</b>        
      getIntervalgetTimeout.addEventListener('click', startTimer); 
       function timerId() { 
         div('spoon', setIntervalSetTimeout); 
        };
      function startTimer() { 
        let variableTimerId = setInterval(timerId, 500); 
        setTimeout(function () { 
          clearInterval(variableTimerId);
          div('stop', setIntervalSetTimeout); 
        }, 1999); 
      }
      </pre>
      <button id="btn-get-interval">get Interval</button>
    </fieldset>
    <fieldset>
      <legend>get param</legend>
      <p>
        мы как-бы вызываем в другой фукции и передаем ей то что содержится в этой но не хватает в той, которой мы передаем.
      </p>
      <pre>
        <b>example</b>        
           function value(val) { 
             return val.value; 
            } 
           
           elem.onblur = function someFunc() { 
             value(this); //здесь мы передаем this в функцию value() 
            }
      </pre>
    </fieldset>
    <fieldset>
      <legend>КЛИК ВКЛ - ВЫКЛ</legend>
      <p>
        Один клик включает что то второй выключает. Типа тригера.
      </p>
      <pre>
        <b>example</b>        
            colorSwitch2.addEventListener('click', startSortArr); 
           
            function startSortArr() { 
              this.removeEventListener('click', startSortArr);
              this.addEventListener('click', dismissSortArr); 
              console.log('on'); 
            } 
          
            function dismissSortArr () { 
              this.removeEventListener('click', dismissSortArr); 
              this.addEventListener('click', startSortArr); 
              console.log('off'); 
            }
      </pre>
    </fieldset>
    <fieldset>
      <legend>ОБНУЛЕНИЕ СЧЕТЧИКА</legend>
      <p>
        Если что то превывает нужное кол-во. Мы можем его обнулить. Вот таким вот незамысловатым образом.
      </p>
      <pre>
        <b>example</b>        
            if (x >= colorArr.length) { 
              x = 0 
            }
      </pre>
    </fieldset>
    <fieldset>
      <legend>ФУНКЦИЯ В функции и область видимости</legend>
      <p>
        вызов функции в другой функции
      </p>

      <pre>
        <b id="wrap-scape-var">result:</b>        
          var landscape = function () { 
            var result = ""; 
            var flat = function (size) { 
              for (var count = 0; count < size; count++) {
                result +="_" ; 
              } }; 
            var mountain=f unction (size) { 
              result +="/" ; for (
              var count=0 ; 
              count < size; 
              count++) { 
            result +="'"; 
          } 
          result +='\\' ; 
        }; 
        flat(3); 
        mountain(4); 
        flat(6); 
        mountain(1); 
        flat(1); 
        return result; 
      }; 
      div(landscape());
      </pre>
    </fieldset>
    <fieldset>
      <legend>ОБНУЛЕНИЕ СЧЕТЧИКА</legend>
      <p>
        Функция future() будет вызвана в любом месте кода - даже если она ниже места где мы ее вызывает. Она не будет работать по
        правилу сверху-вниз в отличии от var future = function() {...}
      </p>
      <p>Также стандартами языка JS не нужно помещать функции внутрь условного блока или цикла</p>
      <pre>
        <b>result: The future says: We STILL have no flying cars.</b>        
        console.log("The future says:", future()); 
        
        function future() { 
          return "We STILL have no flying cars."; 
        }
      </pre>
      <pre>
        <b>example</b>        
        function example() { 
          function a() {} // Нормуль 
          if (something) { 
            function b() {} // Ай-яй-яй! 
          }
        }
      </pre>
    </fieldset>
    <fieldset>
      <legend>Замыкания</legend>
      <p>
        Возможность использовать вызовы функций как переменные вкупе с тем фактом, что локальные переменные каждый раз при вызове
        функции создаются заново. Дает нам возможность создавать функцию в функции. Параметры которых могут взаимодействовать
        друг с другом.
      </p>
      <p>
        Мы вкладываем функцию в переменную и функции даем параметр. А потом даем переменной параметр который будет параметром второй
        функции - в функции которую положили в переменную.
      </p>
      <pre>
        <b>result: 10</b>        
         function multiplier(factor) { 
           return function(number) { 
             return number * factor; 
            }; 
          } 
          var twice = multiplier(2); 
          console.log(twice(5));
      </pre>
    </fieldset>
    <fieldset>
      <legend>WHIle</legend>
      <p>
        Всегда число будет трех-значное.
      </p>
      <pre>
        <b>result: 004, 044, 444</b>        
         function inventory (cows) { 
           let x = 0; 
           let cowsStr = String(cows); 
           while (cowsStr.length < 3) { 
             cowsStr='0' + cowsStr; 
             x++;
          };
            console.log(cowsStr); 
          }; 
          inventory(4);
          inventory(44);
          inventory(444);
      </pre>
      <pre>
         while (true) { 
           // ... 
          }
      </pre>
    </fieldset>

    <fieldset>
      <legend>trigger</legend>
      <p>
        Кастомный тригер на on/off по клику
      </p>
      <pre>
        <b>result:</b>        
         function checkOn() { 
            this.addEventListener('click', checkOff); 
            this.removeEventListener('click', checkOn); 
          } 
          function checkOff() { 
            this.removeEventListener('click', checkOff); 
            this.addEventListener('click', checkOn); 
          }
      </pre>
    </fieldset>

    <fieldset>
      <legend>Обьект</legend>
      <p>Создание нового обьекта</p>
      <pre>
        <b>result:</b>        
         test2=new Object() тоже что test = {};
      </pre>
      <p>Скопировать свойства из одного-несколько обьектов в один метод COPY</p>
      <div>
        <b>copy(dst, src1, src2…)</b>
        <p>
          Копирует свойства из объектов src1, src2,... в объект dst
        </p>
      </div>
      <pre>
        var vasya = { age: 21, name: 'Вася', surname: 'Петров' }; 
        var user = { isAdmin: false, isEmailConfirmed: true }; 
        var student = { university: 'My university' }; 

        <b>copy(vasya, user, student);</b>

        alert( vasya.isAdmin); // false 
        alert( vasya.university ); // My university

        // скопирует все свойства в пустой объект 
        var userClone = copy({}, user);
      </pre>
      <p>
        В обьектах могут находится как другие обьекты - так и функции. В функиях this будет ссылка на обьект в котором она используется.
      </p>
      <pre>
        <b>result: Hello, Петя.</b>        
         test= { simple_property: 'Hello', 
         object_property: { 
           user_1: 'Петя', 
           user_2: 'Вася' 
          }, 
          function_property: function(user) { 
            alert(this.simple_property + ', ' + this.object_property[user]); 
          } 
        } 
        test.function_property('user_1'); //Hello, Петя.
      </pre>
    </fieldset>
    <fieldset>
      <legend>метод Call для функций</legend>
      <p>
        this в любой функции ссылается на обьект, который вызывает эту функцию. Поэтому, кроме this, можно еще передавать другие
        параметры.
      </p>
      <pre>
        <b>result:</b>        
        code
      </pre>
      <p id="method-call"></p>
    </fieldset>
    <fieldset>
      <legend>text</legend>
      <p>
        desription
      </p>
      <pre>
        <b id="future-says">result:</b>        
         console.log("The future says:", future()); 
         function future() { 
           return "We STILL have no flying cars."; 
          }
      </pre>
    </fieldset>
    <fieldset>
      <legend>this и универсальные функции</legend>
      <p>
        Только при вызове функции мы указывает this(где мы указываем элементы с которымм что-то должна зделать функция). В сасой
        функции универсальной фун-ции this будет window или undefined.
      </p>
      <pre>
        function addEvent(remove, add, elem) { 
          elem.removeEventListener('click', remove); 
          elem.addEventListener('click', add); 
        };
        addEvent(this, first, lost);
      </pre>
    </fieldset>
    <fieldset>
      <legend>методы this</legend>
      <p>
        func.call(elem, x1, x2) func.apply(elem, [x1, x2]) func.bind(elem)
      </p>
      <pre>
        <b>result: Значение этого элемента : 66</b>        
          let elem = document.getElementsByTagName('input')[0]; 
         
          function func(x1, x2) { 
           console.log("Значение" + x1 + x2 + this.value);
          } 
          
          func.call(elem, ' этого', ' элемента : ');        I method
          func.apply(elem, [' этого', ' элемента : ']);     II method
          
          let arr = [' этого', ' элемента : ']; 
          func.apply(elem, arr);                            III method

          let newFunc = func.bind(elem);                   IV method
          newFunc("один", "два"); //это аналог func(), если мы что-то меняем изначальной функции меняется и в newFunc(). Мы точно такжне можем передать в нее параметры
          console.log('​newFunc();', newFunc);

          //Если нету addEventListener такое не будет работать
          function func1(v) { 
            console.log(v); 
          } 
          div(func1(this));
      </pre>
    </fieldset>
    <fieldset>
      <legend>getRandom</legend>
      <p>
        Получить случайное число в этом промежутке
      </p>
      <pre>
        <b>result: ~min-max</b>        
          function getRandom(min, max) { 
            return Math.floor(Math.random() * (max - min) + min); 
          }
      </pre>
    </fieldset>
    <fieldset>
      <legend>SUBMIT - forms</legend>
      <p>
        Событие как на enter, так и по клику
      </p>
      <pre>
        <b>result:</b>        
        <form method="POST" action="" id="form_who_should_be_checked">
          <input name="anything" value="text"> 
          <input type="submit"> 
        </form>
        document.getElementById("form_who_should_be_checked").onsubmit = 
        
        function() { 
          alert(this.anything.value); 
          return false;
        }
      </pre>
      <script>
        document.getElementById("form_who_should_be_checked").onsubmit =

          function () {
            alert(this.anything.value);
            return false;
          }
      </script>
    </fieldset>
    <fieldset>
      <legend>Флаги - Flags</legend>
      <p>
        Флаги полезны когда нужно зделать перебор но вернуть только булеан
      </p>
      <pre>
        <b>result: true or false</b>        
          let mas = ['a','b','c','d','e','c']; 
          function hasElem(mass, num) { 
            for (let i=0; i < mass.length; i++) { 
              if (num==m ass[i]) { 
                return true; 
              } 
            } 
            return false; 
          }; 
          alert(hasElem(mas, 'c'));
      </pre>
    </fieldset>
    <fieldset>
      <legend>Вызов функции</legend>
      <p>
        Любопытный вызов функции
      </p>
      <pre>
        <b>result:</b>        
        function getTitle (){ 
          var title = "default title"; 
          var showTitle = function(){ 
            alert(title); 
          }; 
          var setTitle = function(newTitle){
            title = newTitle; 
          }; return { 
            "showTitle": showTitle, 
            "setTitle": setTitle 
          }; 
        } 
        var t = getTitle(); 
        t.showTitle(); 
        t.setTitle("Hello World"); 
        t.showTitle();

        var t1 = getTitle(); 
        t1.setTitle("Hello World 1"); 
        var t2 = getTitle(); 
        t2.setTitle("Hello World 2"); 
        t1.showTitle(); 
        t2.showTitle();
      </pre>
    </fieldset>
    <fieldset>
      <legend>text</legend>
      <p>
        desription
      </p>
      <pre>
        <b>result:</b>        
        code
      </pre>
    </fieldset>
    <fieldset>
      <legend>text</legend>
      <p>
        desription
      </p>
      <pre>
        <b>result:</b>        
        code
      </pre>
    </fieldset>
    <fieldset>
      <legend>text</legend>
      <p>
        desription
      </p>
      <pre>
        <b>result:</b>        
        code
      </pre>
    </fieldset>
    <fieldset>
      <legend>text</legend>
      <p>
        desription
      </p>
      <pre>
        <b>result:</b>        
        code
      </pre>
    </fieldset>
    <fieldset>
      <legend>text</legend>
      <p>
        desription
      </p>
      <pre>
        <b>result:</b>        
        code
      </pre>
    </fieldset>

  </div>
  <script src="js/main.js"></script>
  <script src="js/practice.js"></script>
</body>

</html>