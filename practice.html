<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <link rel="stylesheet" href="css/style.css">
</head>

<body>

  <a href="index.html">home</a>
  <blockquote>
    <h3>practice</h3>
    <ol>
      <li>
        стрелочная функция
      </li>
      <li>
        метод перебора массива forEach
      </li>
      <li>
        стрелочная функция для forEach
      </li>
    </ol>
  </blockquote>

  <div class="container">
    <fieldset>
      <!-- \\__====|_ ПРАКТИКА _|===// -->
      <legend>Напоминалка Code</legend>
      <ol>
        <li>
          parseInt(somestring) to -> number
        </li>
        <li>
          Создать эл. и вставить
          <pre>
            let divEl = document.createElement('div');
            divEl.className = "includer"; 
            divEl.innerHTML = str;
            location.appendChild(divEl);
          </pre>
        </li>
        <li>
          String(num) -> преобразовать в строку
        </li>
        <li>
          querySelector('tag-or-class-or-id') -> найти нужный елемент
        </li>
        <li>
          user-select: none -- отменяет выделение
        </li>
        <li>
          document.querySelectorAll(selectors) -- аналог getElement(s)By
        </li>
        <li>
          .addEventListener('mouseup', func) -- срабатывает при отжатии мышки
        </li>
        <li>
          input.setAttribute('disabled', 'disabled'); -- зделать input неактывным.
        </li>
        <li>
          let interval = setInterval(countdown, 500) -- задать интервал выполнения
        </li>
        <li>
          function stop() { window.clearInterval(interval) } -- прекратить интервал выполнения
        </li>
        <li>
          while(true) { ... }
        </li>
        <li>
          if (this.checked == true) {} the same(тоже самое) что if (this.chicked) {}
        </li>
        <li>
          arr.push(item) - добавляет новый элемент в нач. массива
        </li>
        <li>
          arr = value.split(',') - разбивает строку на массив по символу
        </li>
        <li>
          arr.join(', ') - соеденить массив в строку и поставить кому между ел.
        </li>
        <li>
          addEventListener('change') -- вешается на checkbox'ы
        </li>
        <li>
          checkbox.checked -- достучатся до выбраного checkbox
        </li>
        <li>
          Добавлять css через js 1 элемент --
          <pre>
            elem.style.display = 'none';
          </pre> 2 элемента --
          <pre>
            unvizInput.style = { 'display':'none'; 'color': 'orange' }; 
          </pre>
        </li>
        <li>
          elem.getAttribute() -- получить доступ к атрибуту elem.setAttribute() -- дать эл. аттр. elem.hasAttribute() -- приверить
          на наличие аттрибута elem.removeAttribute(name) -- удаляет аттр.
        </li>
        <li>
          Добавить и удалить класс
          <pre>
             classList.remove('page'); // удалить класс 
             classList.add('post'); // добавить класс
          </pre>
        </li>
        <li>
          Методы строк String.prototype.slice() Извлекает часть строки и возвращает новую строку. String.prototype.split() Разбивает
          объект String на массив строк, разделёных указанной строкой на подстроки.
        </li>
        <li>
          Метод call позволяет вызвать функцию из другого обьекта.
          <pre>
             test.function_property.call(test2, 'user_1');
          </pre>
        </li>
        <li>
          Возвращает минимальное и максимальное значение массива
          <pre>
             Math.min.apply(null, [3,5,2]) //2
             Math.max.apply(null, [3,5,2]) //5
          </pre>
        </li>
        <li>
          Удалить элемент из массива
          <pre>
            <p>result: ['bar', 'baz']</p>
             var a = ['foo', 'bar', 'baz']; 
             a.splice(0,1) -- удаляет один элемент начиная с позиции 0
          </pre>
        </li>
        <li>
          Сортировка массива
          <pre>
             function compareNumbers(a, b) { 
               return a - b; 
             } -- Функция для сортировки чисел
             используется с методом sort
             
             arr.sort(compareNumbers) -- метод .Sort()
          </pre>
        </li>
        <li></li>
        <li></li>
      </ol>
    </fieldset>
    <!-- \\__====|_ ТЕОРИЯ _|===// -->
    <fieldset>
      <legend>Теория Напоминалка</legend>
      <ol>
        <li>
          Нужно не забывать что повторяющаяся функция переписывает переменные на начальные, если они находятся в середине.
        </li>
        <li>
          Также верхнее this можно положить опять таки в переменную, которую передать в функции пониже.
          <pre>let that = this.value;</pre>
        </li>
        <li>
          очень удобно, когда то что мы должны зделать с элементом лежит в самом элементе в VALUE = "..."
          <pre>
            input type="checkbox" value="font-weight:bold;">сделать жирным
          </pre>
        </li>
        <li>
          <h6>Литералы</h6>
          Не стоит путать использование примитивных значений с использованием литералов — например :
          <pre>
             «test=new Array()» или как «test=[]»
           </pre>
        </li>
        <li>

        </li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
      </ol>
    </fieldset>
    <fieldset>
      <legend>стрелочная функция</legend>
      <p>Перевод input в верхний регистр</p>
      <pre>
        <b>old</b>
         function toUpper(str) {return str.toUpperCase()}
      </pre>
      <pre>
        <b>new</b>
         let toUpper = str => str.toUpperCase();
      </pre>
      <input id="input" type="text" value="">
    </fieldset>

    <fieldset>
      <legend>blur</legend>
      <p>Передает параметры в консоль</p>
      <input type="text" id="task">
      <pre>
        <b>old</b>
         let task = document.getElementById('task'); 
         function value(val) { 
           console.log(val.value); // принимаем value с другой функции
        и здесь мы можем делать с ним что угодно 
        } 
        task.onblur = function someFunc() { 
          value(this) //передаем значение this при blure.
          Получается мы здесь вызываем другую функцию дав ей в параметр то что нужно этой функции 
        }
      </pre>
    </fieldset>

    <fieldset>
      <legend>forEach</legend>
      <p>
        let someArr = ['значение1', 'значение2', 'значение3'];
      </p>
      <pre>
        <b id="wrap-for-each1">result</b>
         someArr.forEach(function callback(currentValue, index, array) { 
           div('this is value : ' + currentValue); 
           div('this is index: ' + index); 
           div('this is array : ' + array); 
          });
      </pre>
      <button id="but">click</button>
    </fieldset>

    <fieldset>
      <legend>forEach стрелочная функция</legend>
      <p>
        let someArr = ['значение1', 'значение2', 'значение3']; выводит значения массива в дивы
      </p>
      <pre>
        <b id="wrap-for-each2">result</b>        
         someArr.forEach(callback = (currentValue, index, array) => (console.log(currentValue)));
      </pre>
      <button id="but2">click</button>
    </fieldset>

    <fieldset>
      <legend>setInterval ^ setTimeout</legend>
      <p>
        setInterval - задает интервал повторного выполнения функции, setTimeout - прекращает это. Третий пример с использованием
        рекурсивного setTimeout - true way.
      </p>
      <pre>
        <b id="wrap-set-interval">result</b>        
      getIntervalgetTimeout.addEventListener('click', startTimer); 
       function timerId() { 
         div('spoon', setIntervalSetTimeout); 
        };
      function startTimer() { 
        let variableTimerId = setInterval(timerId, 500); 
        setTimeout(function () { 
          clearInterval(variableTimerId);
          div('stop', setIntervalSetTimeout); 
        }, 1999); 
      }
      </pre>
      <button id="btn-get-interval">get Interval</button>
    </fieldset>
    <fieldset>
      <legend>get param</legend>
      <p>
        мы как-бы вызываем в другой фукции и передаем ей то что содержится в этой но не хватает в той, которой мы передаем.
      </p>
      <pre>
        <b>example</b>        
           function value(val) { 
             return val.value; 
            } 
           
           elem.onblur = function someFunc() { 
             value(this); //здесь мы передаем this в функцию value() 
            }
      </pre>
    </fieldset>
    <fieldset>
      <legend>КЛИК ВКЛ - ВЫКЛ</legend>
      <p>
        Один клик включает что то второй выключает. Типа тригера.
      </p>
      <pre>
        <b>example</b>        
            colorSwitch2.addEventListener('click', startSortArr); 
           
            function startSortArr() { 
              this.removeEventListener('click', startSortArr);
              this.addEventListener('click', dismissSortArr); 
              console.log('on'); 
            } 
          
            function dismissSortArr () { 
              this.removeEventListener('click', dismissSortArr); 
              this.addEventListener('click', startSortArr); 
              console.log('off'); 
            }
      </pre>
    </fieldset>
    <fieldset>
      <legend>ОБНУЛЕНИЕ СЧЕТЧИКА</legend>
      <p>
        Если что то превывает нужное кол-во. Мы можем его обнулить. Вот таким вот незамысловатым образом.
      </p>
      <pre>
        <b>example</b>        
            if (x >= colorArr.length) { 
              x = 0 
            }
      </pre>
    </fieldset>
    <fieldset>
      <legend>ФУНКЦИЯ В функции и область видимости</legend>
      <p>
        вызов функции в другой функции
      </p>

      <pre>
        <b id="wrap-scape-var">result:</b>        
          var landscape = function () { 
            var result = ""; 
            var flat = function (size) { 
              for (var count = 0; count < size; count++) {
                result +="_" ; 
              } }; 
            var mountain=f unction (size) { 
              result +="/" ; for (
              var count=0 ; 
              count < size; 
              count++) { 
            result +="'"; 
          } 
          result +='\\' ; 
        }; 
        flat(3); 
        mountain(4); 
        flat(6); 
        mountain(1); 
        flat(1); 
        return result; 
      }; 
      div(landscape());
      </pre>
    </fieldset>
    <fieldset>
      <legend>ОБНУЛЕНИЕ СЧЕТЧИКА</legend>
      <p>
        Функция future() будет вызвана в любом месте кода - даже если она ниже места где мы ее вызывает. Она не будет работать по
        правилу сверху-вниз в отличии от var future = function() {...}
      </p>
      <p>Также стандартами языка JS не нужно помещать функции внутрь условного блока или цикла</p>
      <pre>
        <b>result: The future says: We STILL have no flying cars.</b>        
        console.log("The future says:", future()); 
        
        function future() { 
          return "We STILL have no flying cars."; 
        }
      </pre>
      <pre>
        <b>example</b>        
        function example() { 
          function a() {} // Нормуль 
          if (something) { 
            function b() {} // Ай-яй-яй! 
          }
        }
      </pre>
    </fieldset>
    <fieldset>
      <legend>Замыкания</legend>
      <p>
        Возможность использовать вызовы функций как переменные вкупе с тем фактом, что локальные переменные каждый раз при вызове
        функции создаются заново. Дает нам возможность создавать функцию в функции. Параметры которых могут взаимодействовать
        друг с другом.
      </p>
      <p>
        Мы вкладываем функцию в переменную и функции даем параметр. А потом даем переменной параметр который будет параметром второй
        функции - в функции которую положили в переменную.
      </p>
      <pre>
        <b>result: 10</b>        
         function multiplier(factor) { 
           return function(number) { 
             return number * factor; 
            }; 
          } 
          var twice = multiplier(2); 
          console.log(twice(5));
      </pre>
    </fieldset>
    <fieldset>
      <legend>WHIle</legend>
      <p>
        Всегда число будет трех-значное.
      </p>
      <pre>
        <b>result: 004, 044, 444</b>        
         function inventory (cows) { 
           let x = 0; 
           let cowsStr = String(cows); 
           while (cowsStr.length < 3) { 
             cowsStr='0' + cowsStr; 
             x++;
          };
            console.log(cowsStr); 
          }; 
          inventory(4);
          inventory(44);
          inventory(444);
      </pre>
      <pre>
         while (true) { 
           // ... 
          }
      </pre>
    </fieldset>

    <fieldset>
      <legend>trigger</legend>
      <p>
        Кастомный тригер на on/off по клику
      </p>
      <pre>
        <b>result:</b>        
         function checkOn() { 
            this.addEventListener('click', checkOff); 
            this.removeEventListener('click', checkOn); 
          } 
          function checkOff() { 
            this.removeEventListener('click', checkOff); 
            this.addEventListener('click', checkOn); 
          }
      </pre>
    </fieldset>
    <fieldset>
      <legend>Обьект</legend>
      <p>
        Создание нового обьекта
      </p>
      <pre>
        <b>result:</b>        
         test2=new Object() тоже что test = {};
      </pre>
    </fieldset>
    <fieldset>
      <legend>Обьект</legend>
      <p>
        В обьектах могут находится как другие обьекты - так и функции. В функиях this будет ссылка на обьект в котором она используется.
      </p>
      <pre>
        <b>result: Hello, Петя.</b>        
         test= { simple_property: 'Hello', 
         object_property: { 
           user_1: 'Петя', 
           user_2: 'Вася' 
          }, 
          function_property: function(user) { 
            alert(this.simple_property + ', ' + this.object_property[user]); 
          } 
        } 
        test.function_property('user_1'); //Hello, Петя.
      </pre>
    </fieldset>
    <fieldset>
      <legend>метод Call для функций</legend>
      <p>
        this в любой функции ссылается на обьект, который вызывает эту функцию. Поэтому, кроме this, можно еще передавать другие
        параметры.
      </p>
      <pre>
        <b>result:</b>        
        code
      </pre>
      <p id="method-call"></p>
    </fieldset>
    <fieldset>
      <legend>text</legend>
      <p>
        desription
      </p>
      <pre>
        <b id="future-says">result:</b>        
         console.log("The future says:", future()); 
         function future() { 
           return "We STILL have no flying cars."; 
          }
      </pre>
    </fieldset>
    <fieldset>
      <legend>text</legend>
      <p>
        desription
      </p>
      <pre>
        <b>result:</b>        
        code
      </pre>
    </fieldset>
    <fieldset>
      <legend>text</legend>
      <p>
        desription
      </p>
      <pre>
        <b>result:</b>        
        code
      </pre>
    </fieldset>
    <fieldset>
      <legend>text</legend>
      <p>
        desription
      </p>
      <pre>
        <b>result:</b>        
        code
      </pre>
    </fieldset>
    <fieldset>
      <legend>text</legend>
      <p>
        desription
      </p>
      <pre>
        <b>result:</b>        
        code
      </pre>
    </fieldset>

  </div>
  <script src="js/main.js"></script>
  <script src="js/practice.js"></script>
</body>

</html>