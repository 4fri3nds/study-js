<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <link rel="stylesheet" href="css/style.css">
</head>

<body>

  <a href="index.html">home</a>
  <blockquote>
    <h3>practice</h3>
    <ol>
      <li>
        стрелочная функция
      </li>
      <li>
        метод перебора массива forEach
      </li>
      <li>
        стрелочная функция для forEach
      </li>
    </ol>
  </blockquote>

  <div class="container">
    <fieldset>
      <!-- \\__====|_ ПРАКТИКА _|===// -->
      <legend>Напоминалка Code</legend>
      <ol>
        <li>
          Преображение типов данных
          <pre>
            parseInt(somestring) to -> number
            String(num) -> преобразовать в строку
          </pre>
        </li>
        <li>
          Создать эл. и вставить
          <pre>
            let divEl = document.createElement('div');
            divEl.className = "includer"; 
            divEl.innerHTML = str;
            location.appendChild(divEl);
          </pre>
        </li>
        <li>
          задать интервал выполнения
          прекратить интервал выполнения
          <pre>
            let interval = setInterval(countdown, 500)
            function stop() { window.clearInterval(interval) } 
          </pre>
        </li>
        <li>
          <p>Метод WHILE</p>
          <pre>
            while(true) { ... }
          </pre>
        </li>
        <li>
          Добавить и удалить классы
          <pre>
            document.body.classList.add('thisClass'); 
            document.body.classList.remove('thatClass');
            document.body.classList.toggle('anotherClass'); 

            body.classList.contains('thatClass') -- проверка на наличие
          </pre>
        </li>
        <li>
          Управление DOM елементами
          <pre>
            - getElementById id - везде 
            - getElementsByName name - везде   
            - getElementsByTagName - тег или '*' - получить всех потомков, 
            - getElementsByClassName
            - querySelector 
            - querySelectorAll - ('ul > li:last-child')

            - elem.matches(css) ничего не ищет, а проверяет, удовлетворяет ли elem селектору css. Он возвращает true либо false.
            
            elem.closest(css)
            parentNode возвращает родитель элемента.
            parentElement
            childNodes()
            children - только дочерние узлы-элементы, то есть соответствующие тегам
            firstChild, lastChild -  – соответственно, первый и последний дети-элементы
            previousElementSibling, nextElementSibling – соседи-элементы
          </pre>
        </li>
        <li>
          <p>МАССИВЫ</p>
          <pre>
            arr.push(item) - добавляет новый элемент в нач. массива
            arr.join(', ') - соеденить массив --> строку и поставить кому между ел.
          </pre>
        </li>
        <li>
          <p>СТРОКИ</p>
          <pre>
            arr = value.split(',') - разбивает строку --> массив по символу
            slice(start, end) 
            substring(start, end) 
            substr(start, length)
            charAt -- узнаем какой именно символ(на этой позиции)
          </pre>
        </li>
        <li>
        </li>
        <li>
          addEventListener события
          <pre>
            checkbox.addEventListener('change') -- вешается на checkbox'ы
            checkbox.addEventListener('checked') -- вешается на checkbox'ы
            .addEventListener('mouseup', func) -- срабатывает при отжатии мышки
          </pre>
        </li>
        <li>
          Добавлять css через js
          <pre>
            elem.style.display = 'none';
            css - user-select: none -- отменяет выделение          
          </pre>
        </li>
        <li>
          <p>АТТРИБУТЫ</p>
          <pre>
            elem.getAttribute() -- получить доступ к атрибуту 
            elem.setAttribute() -- дать эл. аттр. 
            elem.hasAttribute() -- приверить на наличие аттрибута 
            elem.removeAttribute(name) -- удаляет аттр.

            input.setAttribute('disabled', 'disabled'); -- зделать input неактывным.
          </pre>
        </li>
        <li>
          Добавить и удалить класс
          <pre>
             classList.remove('page'); // удалить класс 
             classList.add('post'); // добавить класс
          </pre>
        </li>
        <li>
          Методы строк String.prototype.slice() Извлекает часть строки и возвращает новую строку. String.prototype.split() Разбивает
          объект String на массив строк, разделёных указанной строкой на подстроки.
        </li>
        <li>
          Метод call позволяет вызвать функцию из другого обьекта.
          <pre>
             test.function_property.call(test2, 'user_1');
          </pre>
        </li>
        <li>
          Возвращает минимальное и максимальное значение массива
          <pre>
             Math.min.apply(null, [3,5,2]) //2
             Math.max.apply(null, [3,5,2]) //5
          </pre>
        </li>
        <li>
          Удалить элемент из массива
          <pre>
            <p>result: ['bar', 'baz']</p>
             var a = ['foo', 'bar', 'baz']; 
             
             a.splice(0,1) -- удаляет один элемент начиная с позиции 0
          </pre>
        </li>
        <li>
          Сортировка массива
          <pre>
             function compareNumbers(a, b) { 
               return a - b; 
             } -- Функция для сортировки чисел, используется с методом sort
             
             arr.sort(compareNumbers) -- метод .Sort()
          </pre>
        </li>
        <li>
          Передача и использование this в универсальной функции
          <pre>
            func.call(elem, x1, x2)
            func.apply(elem, [x1, x2]) 
            func.bind(elem)
          </pre>
        </li>
        <li>
          Вот так засунуть выполнение функции в true - false
          <pre>
            var bool = true;

            if (bool) { var func = function () { alert('!'); } 
            } else { var func = function () { alert('!!'); } } 
            
            func();
          </pre>
        </li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
      </ol>
    </fieldset>
    <!-- \\__====|_ ТЕОРИЯ _|===// -->
    <fieldset>
      <legend>Теория Напоминалка</legend>
      <ol>
        <li>
          Нужно не забывать что повторяющаяся функция переписывает переменные на начальные, если они находятся в середине.
        </li>
        <li>
          Также верхнее this можно положить опять таки в переменную, которую передать в функции пониже.
          <pre>let that = this.value;</pre>
        </li>
        <li>
          очень удобно, когда то что мы должны зделать с элементом лежит в самом элементе в VALUE = "..."
          <pre>
            input type="checkbox" value="font-weight:bold;">сделать жирным
          </pre>
        </li>
        <li>
          <h6>Литералы</h6>
          Не стоит путать использование примитивных значений с использованием литералов — например :
          <pre>
             «test=new Array()» или как «test=[]»
           </pre>
        </li>
        <li>
          Употребление this в функции.
          Чтобы передать this - нужно передать это в параметр. Откуда ее вызываем.
          <pre>
            triggerClassActive(this, sumCellsArr, x);    
          </pre>
        </li>
        <li>
           LexicalEnvironment - ¬се переменные внутри функции Ц это свойства специального внутреннего объекта LexicalEnvironment, который
          создаЄтс€ при еЄ запуске. «амыкани€, функции изнутри
        </li>
        <li>
           let - let, которое работает как var, но создаЄт переменные, локальные дл€ любого данного блока, а не только дл€ функции.
          Ѕлок имеетс€ ввиду все что стоит в фигурных скобках - {}
        </li>
        <li>
           ѕор€док вызова функций ћесто, где компьютер запоминает контекст, называетс€ стеком. function greet(who) { console.log("ѕривет,
          " + who); //first } greet("—емЄн"); console.log("ѕокеда"); //second  аждый раз при вызове функции, текущий контекст помещаетс€
          наверх стека.  огда функци€ возвращаетс€, она забирает верхний контекст из стека и использует его дл€ продолжени€ работы.
        </li>
        <li>
           ѕовторение цикла по-научному называетс€ Ђитераци€ї
        </li>
        <li>
          <pre>
            //Function Declaration: function func() { alert('!'); }); 
            
            //Function Expression: var func = function() { alert('!'); });
          </pre>
        </li>
        <li>
          Использование 'use strict' может вызвать кучу ошибок.
          <pre>
            "use strict"; 
            var bool = true; 
            if (bool) { 
              function func() { 
                alert('!'); } 
              } 
            func(); //выдаст ошибку - тут функция не видна!
          </pre>
        </li>
        <li>
          В js функции не копируются, а ссылаются друг на друга. 
          <pre>
            function func() { alert('!'); }); 
            var test = func; //И test и func указывают на одну и ту же функцию
          </pre>
        </li>
        <li>
          Можно передать функцию параметром
          <pre>
             var get1 = function() { return 1; } var get2 = function() { return 2; }
             
             function go(func1, func2) { 
               alert(func1() + func2()); 
              } 
              
              go(get1, get2); //выведет 3
          </pre>
        </li>
        <li>
          Так можно использовать анонимную функцию
          <pre>
             function go(func) { 
               func(); 
              }); 
              go(function() { 
                alert('!'); 
              });
          </pre>
        </li>
        <li>
          функция возвращает внутреннюю функцию. Вызвать внутреннюю можно func()()
          <pre>
              function func() { 
                return function() { 
                  return '!'; 
                }; 
              } 
              
              alert( func()() ); //увидим '!'
          </pre>
        </li>
        <li></li>
        <li></li>
      </ol>
    </fieldset>
    <fieldset>
      <legend>стрелочная функция</legend>
      <p>Перевод input в верхний регистр</p>
      <pre>
        <b>old</b>
         function toUpper(str) {return str.toUpperCase()}
      </pre>
      <pre>
        <b>new</b>
         let toUpper = str => str.toUpperCase();
      </pre>
      <input id="input" type="text" value="">
    </fieldset>

    <fieldset>
      <legend>blur</legend>
      <p>Передает параметры в консоль</p>
      <input type="text" id="task">
      <pre>
        <b>old</b>
         let task = document.getElementById('task'); 
         function value(val) { 
           console.log(val.value); // принимаем value с другой функции
        и здесь мы можем делать с ним что угодно 
        } 
        task.onblur = function someFunc() { 
          value(this) //передаем значение this при blure.
          Получается мы здесь вызываем другую функцию дав ей в параметр то что нужно этой функции 
        }
      </pre>
    </fieldset>

    <fieldset>
      <legend>forEach</legend>
      <p>
        let someArr = ['значение1', 'значение2', 'значение3'];
      </p>
      <pre>
        <b id="wrap-for-each1">result</b>
         someArr.forEach(function callback(currentValue, index, array) { 
           div('this is value : ' + currentValue); 
           div('this is index: ' + index); 
           div('this is array : ' + array); 
          });
      </pre>
      <button id="but">click</button>
    </fieldset>

    <fieldset>
      <legend>forEach стрелочная функция</legend>
      <p>
        let someArr = ['значение1', 'значение2', 'значение3']; выводит значения массива в дивы
      </p>
      <pre>
        <b id="wrap-for-each2">result</b>        
         someArr.forEach(callback = (currentValue, index, array) => (console.log(currentValue)));
      </pre>
      <button id="but2">click</button>
    </fieldset>

    <fieldset>
      <legend>setInterval ^ setTimeout</legend>
      <p>
        setInterval - задает интервал повторного выполнения функции, setTimeout - прекращает это. Третий пример с использованием
        рекурсивного setTimeout - true way.
      </p>
      <pre>
        <b id="wrap-set-interval">result</b>        
      getIntervalgetTimeout.addEventListener('click', startTimer); 
       function timerId() { 
         div('spoon', setIntervalSetTimeout); 
        };
      function startTimer() { 
        let variableTimerId = setInterval(timerId, 500); 
        setTimeout(function () { 
          clearInterval(variableTimerId);
          div('stop', setIntervalSetTimeout); 
        }, 1999); 
      }
      </pre>
      <button id="btn-get-interval">get Interval</button>
    </fieldset>
    <fieldset>
      <legend>get param</legend>
      <p>
        мы как-бы вызываем в другой фукции и передаем ей то что содержится в этой но не хватает в той, которой мы передаем.
      </p>
      <pre>
        <b>example</b>        
           function value(val) { 
             return val.value; 
            } 
           
           elem.onblur = function someFunc() { 
             value(this); //здесь мы передаем this в функцию value() 
            }
      </pre>
    </fieldset>
    <fieldset>
      <legend>КЛИК ВКЛ - ВЫКЛ</legend>
      <p>
        Один клик включает что то второй выключает. Типа тригера.
      </p>
      <pre>
        <b>example</b>        
            colorSwitch2.addEventListener('click', startSortArr); 
           
            function startSortArr() { 
              this.removeEventListener('click', startSortArr);
              this.addEventListener('click', dismissSortArr); 
              console.log('on'); 
            } 
          
            function dismissSortArr () { 
              this.removeEventListener('click', dismissSortArr); 
              this.addEventListener('click', startSortArr); 
              console.log('off'); 
            }
      </pre>
    </fieldset>
    <fieldset>
      <legend>ОБНУЛЕНИЕ СЧЕТЧИКА</legend>
      <p>
        Если что то превывает нужное кол-во. Мы можем его обнулить. Вот таким вот незамысловатым образом.
      </p>
      <pre>
        <b>example</b>        
            if (x >= colorArr.length) { 
              x = 0 
            }
      </pre>
    </fieldset>
    <fieldset>
      <legend>ФУНКЦИЯ В функции и область видимости</legend>
      <p>
        вызов функции в другой функции
      </p>

      <pre>
        <b id="wrap-scape-var">result:</b>        
          var landscape = function () { 
            var result = ""; 
            var flat = function (size) { 
              for (var count = 0; count < size; count++) {
                result +="_" ; 
              } }; 
            var mountain=f unction (size) { 
              result +="/" ; for (
              var count=0 ; 
              count < size; 
              count++) { 
            result +="'"; 
          } 
          result +='\\' ; 
        }; 
        flat(3); 
        mountain(4); 
        flat(6); 
        mountain(1); 
        flat(1); 
        return result; 
      }; 
      div(landscape());
      </pre>
    </fieldset>
    <fieldset>
      <legend>ОБНУЛЕНИЕ СЧЕТЧИКА</legend>
      <p>
        Функция future() будет вызвана в любом месте кода - даже если она ниже места где мы ее вызывает. Она не будет работать по
        правилу сверху-вниз в отличии от var future = function() {...}
      </p>
      <p>Также стандартами языка JS не нужно помещать функции внутрь условного блока или цикла</p>
      <pre>
        <b>result: The future says: We STILL have no flying cars.</b>        
        console.log("The future says:", future()); 
        
        function future() { 
          return "We STILL have no flying cars."; 
        }
      </pre>
      <pre>
        <b>example</b>        
        function example() { 
          function a() {} // Нормуль 
          if (something) { 
            function b() {} // Ай-яй-яй! 
          }
        }
      </pre>
    </fieldset>
    <fieldset>
      <legend>Замыкания</legend>
      <p>
        Возможность использовать вызовы функций как переменные вкупе с тем фактом, что локальные переменные каждый раз при вызове
        функции создаются заново. Дает нам возможность создавать функцию в функции. Параметры которых могут взаимодействовать
        друг с другом.
      </p>
      <p>
        Мы вкладываем функцию в переменную и функции даем параметр. А потом даем переменной параметр который будет параметром второй
        функции - в функции которую положили в переменную.
      </p>
      <pre>
        <b>result: 10</b>        
         function multiplier(factor) { 
           return function(number) { 
             return number * factor; 
            }; 
          } 
          var twice = multiplier(2); 
          console.log(twice(5));
      </pre>
    </fieldset>
    <fieldset>
      <legend>WHIle</legend>
      <p>
        Всегда число будет трех-значное.
      </p>
      <pre>
        <b>result: 004, 044, 444</b>        
         function inventory (cows) { 
           let x = 0; 
           let cowsStr = String(cows); 
           while (cowsStr.length < 3) { 
             cowsStr='0' + cowsStr; 
             x++;
          };
            console.log(cowsStr); 
          }; 
          inventory(4);
          inventory(44);
          inventory(444);
      </pre>
      <pre>
         while (true) { 
           // ... 
          }
      </pre>
    </fieldset>

    <fieldset>
      <legend>trigger</legend>
      <p>
        Кастомный тригер на on/off по клику
      </p>
      <pre>
        <b>result:</b>        
         function checkOn() { 
            this.addEventListener('click', checkOff); 
            this.removeEventListener('click', checkOn); 
          } 
          function checkOff() { 
            this.removeEventListener('click', checkOff); 
            this.addEventListener('click', checkOn); 
          }
      </pre>
    </fieldset>
    <fieldset>
      <legend>Обьект</legend>
      <p>
        Создание нового обьекта
      </p>
      <pre>
        <b>result:</b>        
         test2=new Object() тоже что test = {};
      </pre>
    </fieldset>
    <fieldset>
      <legend>Обьект</legend>
      <p>
        В обьектах могут находится как другие обьекты - так и функции. В функиях this будет ссылка на обьект в котором она используется.
      </p>
      <pre>
        <b>result: Hello, Петя.</b>        
         test= { simple_property: 'Hello', 
         object_property: { 
           user_1: 'Петя', 
           user_2: 'Вася' 
          }, 
          function_property: function(user) { 
            alert(this.simple_property + ', ' + this.object_property[user]); 
          } 
        } 
        test.function_property('user_1'); //Hello, Петя.
      </pre>
    </fieldset>
    <fieldset>
      <legend>метод Call для функций</legend>
      <p>
        this в любой функции ссылается на обьект, который вызывает эту функцию. Поэтому, кроме this, можно еще передавать другие
        параметры.
      </p>
      <pre>
        <b>result:</b>        
        code
      </pre>
      <p id="method-call"></p>
    </fieldset>
    <fieldset>
      <legend>text</legend>
      <p>
        desription
      </p>
      <pre>
        <b id="future-says">result:</b>        
         console.log("The future says:", future()); 
         function future() { 
           return "We STILL have no flying cars."; 
          }
      </pre>
    </fieldset>
    <fieldset>
      <legend>this и универсальные функции</legend>
      <p>
        Только при вызове функции мы указывает this(где мы указываем элементы с которымм что-то должна зделать функция). В сасой функции универсальной фун-ции this будет window или undefined. 
      </p>
      <pre>
        function addEvent(remove, add, elem) { 
          elem.removeEventListener('click', remove); 
          elem.addEventListener('click', add); 
        };
        addEvent(this, first, lost);
      </pre>
    </fieldset>
    <fieldset>
      <legend>методы this</legend>
      <p>
        func.call(elem, x1, x2)
        func.apply(elem, [x1, x2])
        func.bind(elem)
      </p>
      <pre>
        <b>result: Значение этого элемента : 66</b>        
          let elem = document.getElementsByTagName('input')[0]; 
         
          function func(x1, x2) { 
           console.log("Значение" + x1 + x2 + this.value);
          } 
          
          func.call(elem, ' этого', ' элемента : ');        I method
          func.apply(elem, [' этого', ' элемента : ']);     II method
          
          let arr = [' этого', ' элемента : ']; 
          func.apply(elem, arr);                            III method

          let newFunc = func.bind(elem);                   IV method
          newFunc("один", "два"); //это аналог func(), если мы что-то меняем изначальной функции меняется и в newFunc(). Мы точно такжне можем передать в нее параметры
          console.log('​newFunc();', newFunc);

          //Если нету addEventListener такое не будет работать
          function func1(v) { 
            console.log(v); 
          } 
          div(func1(this));
      </pre>
    </fieldset>
    <fieldset>
      <legend>text</legend> 
      <p>
        desription
      </p>
      <pre>
        <b>result:</b>        
        code
      </pre>
    </fieldset>
    <fieldset>
      <legend>text</legend>
      <p>
        desription
      </p>
      <pre>
        <b>result:</b>        
        code
      </pre>
    </fieldset>

  </div>
  <script src="js/main.js"></script>
  <script src="js/practice.js"></script>
</body>

</html>